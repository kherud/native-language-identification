Proceedings of the Thirty-First AAAI Conference on Artificial Intelligence (AAAI-17)

Parallel Asynchronous Stochastic
Variance Reduction for Nonconvex Optimization
Cong Fang, Zhouchen Lin‚àó
Key Laboratory of Machine Perception (MOE), School of EECS, Peking University, P. R. China
Cooperative Medianet Innovation Center, Shanghai Jiao Tong University, P. R. China
fangcong@pku.edu.cn, zlin@pku.edu.cn

where fi (i ‚àà {1, 2, ¬∑ ¬∑ ¬∑ , n}) have L-Lipschitz continuous
gradient (L > 0) but can be nonconvex and n is the number
of functions. A large number of models can be formulated as
Eq. (1), such as neural networks, dictionary learning, and inference in graphical models (Allen-Zhu and Hazan 2016). In
this paper, we focus on algorithms that can efÔ¨Åciently reach
a stationary point satisfying ‚àáf (x)2 ‚â§  , which is a common benchmark for nonconvex algorithms.
The standard method to solve Eq. (1) is through Gradient
Descent (GD) and Stochastic Gradient Descent (SGD). In
large-scale problems, SGD is faster in practice, since it randomly chooses only one sample to estimate the gradient during each update. However, its provable convergence rate is
slower than GD. The Incremental First-order Oracles (IFOs)
complexity for GD and SGD to reach a stationary point are
O( n ) and O( œÉ2 ), respectively, where œÉ is the variance of
stochastic gradient (Ghadimi and Lan 2013).
Variance Reduction (VR) methods are one of the great
varieties of SGD methods which ensure the descent direction to have a bounded variance and so can achieve a much
faster convergence rate compared with SGD. (Johnson and
Zhang 2013) Ô¨Årst propose the Stochastic Variance Reduced
Gradient (SVRG) algorithm and prove that the algorithm
has a linear convergence rate instead of a sublinear rate for
SGD, for strongly convex problems. They have also done a
compelling experiment on neural networks to demonstrate
the advantage on nonconvex problems. Recently, there are
much research (Reddi et al. 2016), (Allen-Zhu and Hazan
2016) that carefully analyse SVRG on nonconvex optimization problems. They both prove that SVRG convergences in

Abstract
Nowadays, asynchronous parallel algorithms have received
much attention in the optimization Ô¨Åeld due to the crucial demands for modern large-scale optimization problems. However, most asynchronous algorithms focus on convex problems. Analysis on nonconvex problems is lacking. For the Asynchronous Stochastic Descent (ASGD) algorithm, the best result from (Lian et al. 2015) can only
achieve an asymptotic O( 12 ) rate (convergence to the stationary points, namely, ‚àáf (x)2 ‚â§ ) on nonconvex
problems. In this paper, we study Stochastic Variance Reduced Gradient (SVRG) in the asynchronous setting. We propose the Asynchronous Stochastic Variance Reduced Gradient (ASVRG) algorithm for nonconvex Ô¨Ånite-sum problems. We develop two schemes for ASVRG, depending on
whether the parameters are updated as an atom or not. We
prove that both of the two schemes can achieve linear speed
2

up1 (a non-asymptotic O( n3 ) rate to the stationary points)
1
for nonconvex problems when the delay parameter œÑ ‚â§ n 3 ,
where n is the number of training samples. We also estab2

1

lish a non-asymptotic O( n 3œÑ 3 ) rate (convergence to the stationary points) for our algorithm without assumptions on œÑ .
This further demonstrates that even with asynchronous updating, SVRG has less number of Incremental First-order Oracles (IFOs) compared with Stochastic Gradient Descent and
Gradient Descent. We also conduct experiments on a shared
memory multi-core system to demonstrate the efÔ¨Åciency of
our algorithm.

Introduction

2

We study nonconvex Ô¨Ånite-sum problems of the form:
1
fi (x),
n i=1
n

min f (x) =

x‚ààRd

1

O( n3 ) for nonconvex problems, which is at least O(n 3 )
faster than GD.
On the other hand, to meet the requirement for modern
large-scale problems, asynchronous parallel algorithms have
received much attention, e.g., Asynchronous Stochastic Gradient Descent (ASGD) (Niu et al. 2011),(Agarwal and Duchi
2011), (Lian et al. 2015), Asynchronous Coordinate Descent (Liu et al. 2015), Asynchronous Dual Coordinate Descent (Hsieh, Yu, and Dhillon 2015), and Asynchronous Alternating Direction Method of Multipliers (Zhang and Kwok
2014). Most existing asynchronous methods focus on convex optimization. So the analysis on large-scale nonconvex
problems, such as neural networks, is lacking. On nonconvex problems, the ASGD algorithm (Lian et al. 2015) can

(1)

‚àó

Corresponding author.
c 2017, Association for the Advancement of ArtiÔ¨Åcial
Copyright 
Intelligence (www.aaai.org). All rights reserved.
1
The linear speed up means that if we use œÑ cores to solve a
problem, it will be at least Œ±œÑ times faster than using only one core
to solve this problem (Œ± > 0). It indicates that the asynchronous
algorithm can still maintain the same convergence rate with the
serial algorithm when we ignore the constant in the convergence
rate.

794

only achieve an asymptotic O( 12 ) rate. The convergence
rates for different algorithms are shown in Table 1.
In this paper, we study the asynchronous variant of SVRG
for nonconvex optimization problems. We choose SVRG
rather than other VR methods since it has a low storage requirement, which is more suitable for optimization with a
large number of variables, such as neural networks. We develop two schemes for Asynchronous Stochastic Variance
Reduced Gradient (ASVRG) depending on whether the parameters are updated as an atom. Distinguished from the
proof of ASGD (Lian et al. 2015), we propose a uniÔ¨Åed
proof for the two schemes. We show that both schemes

Algorithm 1 Serial SVRG
Input x00 , epoch length m, step size Œ≥, and S = K/m.
1 for s = 0 to
nS ‚àí 1 do
2 gs = n1 i=1 ‚àáfi (xs0 ),
3 for k = 0 to m ‚àí 1 do
4
Randomly sample ik from 1, 2, ¬∑ ¬∑ ¬∑ , n,
5
vks = ‚àáfik (xsk ) ‚àí ‚àáfik (xs0 ) + gs ,
6
xsk+1 = xsk ‚àí Œ≥vks ,
7
end for k.
= xsm ,
8 xs+1
0
9 end for s.

2

can achieve a linear speed up (a non-asymptotic O( n3 )
rate to stationary points) for nonconvex problems when
1
the delay parameter œÑ ‚â§ n 3 . We also establish a non2

smooth problems and prove that the convergence rate is
O(1/2 + œÑ 2 /). (Liu et al. 2015) propose an asynchronous
stochastic coordinate descent algorithm and prove that the
near-linear speed up is achievable if œÑ ‚â§ O(n1/2 ) for
smooth convex functions under certain conditions. Another
two works we should mention are (Reddi et al. 2015) and
(Lian et al. 2015). In the Ô¨Årst work, (Reddi et al. 2015) study
asynchronous SVRG on strongly convex functions. They
achieve a linear convergence rate under certain conditions.
For nonconvex problem, (Lian et al. 2015) analyse ASGD
and show that ASGD can achieve an asymptotic O(1/2 )
convergence rate.

1

asymptotic O( n 3œÑ 3 ) rate (convergence to the stationary
point) without any assumption on œÑ . This demonstrates that
with asynchronous updating, SVRG still has a less number
of IFOs compared with SGD and GD. We then experiment
on a shared memory system to validate the speedup properties and demonstrate the efÔ¨Åciency of our algorithm. In
summary, our work makes the following contributions:
‚Ä¢ We devise the ASVRG algorithm for asynchronous largescale nonconvex optimization or distributed systems.
‚Ä¢ We show that ASVRG can achieve linear speed up when
2

1

VR Methods

1

œÑ ‚â§ n 3 and also prove that it has an ergodic O( n 3œÑ 3 )
convergence rate with no assumption on œÑ .

VR methods have received a broad attention in recent years,
e.g., SAG (Schmidt, Roux, and Bach 2013), SVRG (Johnson
and Zhang 2013), and SAGA (Defazio, Bach, and LacosteJulien 2014).
Since we focus on the asynchronous variant of SVRG, we
review SVRG in detail. The algorithm has double loops. In
the outer loop, SVRG deÔ¨Ånes a snapshot vector xs0 , and computes the full gradient. At the inner loop, SVRG computes
the following gradient estimator:

Related Work
Asynchronous Parallel Algorithms
Asynchronous algorithms have achieved great success in
recent years. Up to now, there are lots of practical algorithms. Due to space limit, we only review the algorithms
that have close relation with ours. The Ô¨Årst work is from
(Niu et al. 2011), which proposes a lock free asynchronous
implementation of SGD on a shared memory system, called
HOGWILD!. They also provide a proof of non-asymptotic
O(1/) convergence rate for strongly convex and smooth
objective functions. (Agarwal and Duchi 2011) propose an
implementation of SGD on computer clusters for convex

vks = ‚àáfik (xsk ) ‚àí ‚àáfik (xs0 ) + ‚àáf (xs0 ).

(2)

The algorithm is shown in Algorithm 1, where Œ≥ is step size
and m is the epoch length. To explain that vks has been reduced variance, one can consider the case when xsk is very
close to a stationary point x‚àó . Then we have
vks ‚âà ‚àáfik (x‚àó ) ‚àí ‚àáfik (x‚àó ) + ‚àáf (x‚àó ) = 0,

(3)

‚àó

while for SGD, the gradient estimator is ‚àáfit (x ), which
is not equal to 0. Another observation from Eq. (3) is that
the step size need not decrease to 0 to ensure the convergence, which is different from SGD. In (Johnson and Zhang
2013), the authors prove that it can achieve a linear convergence rate for strongly convex problems. Then (Xiao and
Zhang 2014) study the algorithm in the general convex case.
Recently, in (Reddi et al. 2016) and (Allen-Zhu and Hazan
2016), the authors analyse the algorithm in general nonconvex problems. They show that SVRG convergences in

Table 1: Convergence rates of GD based algorithms to stationary points of non-convex problems (‚ÄúSyn.‚Äù indicates the
algorithm is serial or synchronous in the minibatch mode,
while ‚Äúasyn.‚Äù indicates that the algorithm is asynchronous.
Asym. is short for asymptotic. œÑ is the delay parameter.).
Syn.

Algorithm
GD (Nesterov 2013)
SGD (Ghadimi and Lan 2013)

Convergence Rate
non-asym. O( n )
non-asym. O( 12 )

SVRG (Reddi et al. 2016)
ASGD (Lian et al. 2015)

non-asym. O( n3 )
asym. O( 12 )

Asyn.
ASVRG (ours)

2

non-asym. O(

2
n3



), œÑ ‚â§ n
2

2

O( n3 ). They bound the variance of gradient through the
following equation






E vks 2 ‚â§ E ‚àáf (xsk )2 + L2 E xsk ‚àí xs0 2 . (4)

1
3

1

non-asym. O( n 3œÑ 3 )

795

Our Algorithms

Algorithm 2 ASVRG
Input x00 , epoch length m, step size Œ≥, and S = K/m.
1 for s = 0 to
nS ‚àí 1 do
2 gs = n1 i=1 ‚àáfi (xs0 ),
3 for k = 0 to m ‚àí 1 do
4
Randomly sample ik from 1, 2, ¬∑ ¬∑ ¬∑ , n,
s
5
vj(k)
= ‚àáfik (xsj(k) ) ‚àí ‚àáfik (xs0 ) + gs ,
s
s
6
xk+1 = xsk ‚àí Œ≥vj(k)
,
7
end for k.
= xsm ,
8 xs+1
0
9 end for s.

Due to the rapid development of hardware resources, asynchronous parallelisms have recently been very successful on
many problems, including nonconvex ones, such as neural
networks (Dean et al. 2012),(Paine et al. 2013) and matrix decomposition (Petroni and Querzoni 2014),(Yun et al.
2014). The advantage of asynchronous parallelisms is that
it allows workers to work independently. So it reduces the
system overhead. Though SVRG has a provably faster convergence rate on non-convex problems using one core, the
asynchronous variant of SVRG, which meets the crucial demands for large-scale optimization, has not been studied.
We study two schemes of ASVRG. The Ô¨Årst scheme ensures
the parameter to be updated as an atom, which is common
in star-shaped computer networks, while the other scheme
has no locks during the updates. This scheme is common in
shared memory multi-core systems.

The above algorithm is called ASVRG-atom, since the
value of x is updated as an atom. Whenever x is being updated, it will be locked. So other workers cannot read or
write it during the update. There are differences between
ASVRG-atom and the serial SVRG during the ‚Äúread‚Äù step,
since when a thread has read x and is computing the gradient, other threads might update it during this time. So the
gradient fik (x) might be computed from some early x instead of the current one during the asynchronous updates.
We use xsj(k) to denote the early state of x which is used for
calculating the gradient. Then the algorithm can be written
as Algorithm 2. The advantage of ASVRG-atom is that the
algorithm ensures the gradient to be calculated on a real state
of x. Namely, We have

ASVRG-atom
We Ô¨Årst describe ASVRG-atom, which is common in starshaped computer networks. Since SVRG has two loops, we
implement SVRG in asynchronization in the inner loop. In
each epoch, we compute ‚àáf (xs0 ) and update xsk in asynchronization. There will be a synchronization operation after computing the full gradient and after each epoch, respectively. Since both m and n are always large, the synchronization operation will not cost much time.
More speciÔ¨Åcally, we Ô¨Årst assign 2 global counters k and
j. Then all threads repeat the following two parts independently and simultaneously:
Part I: Computing the Full Gradient
1) (Read) Read the parameter xÃÉs0 from the global memory to
the local memory without locks, and set j = 0.
2) (Loop) While j < n
3)
j = j + 1, globally,
4)
Compute the gradient g = g + ‚àáfj (xÃÉs0 ) locally,
5) (End).
6) Compute the full gradient ‚àáf (xÃÉs0 ) = ‚àáf (xÃÉs0 ) + n1 g globally and with locks .
7) (Synchronization) Wait for other threads to Ô¨Ånish this
step.
Part II: Variance Reduced Gradient Descent
1) (Read) Read the full gradient ‚àáf (xÃÉs0 ) from the global
memory to the local memory without locks, and set k = 0.
2) (Loop) while k < m
3)
k = k + 1, globally,
4)
(Read) xÃÉsk from the global memory with locks ,
5)
(Sample) Randomly select a training samples ik ,
6)
Compute vks through Eq. (2) locally.
7)
Update xÃÉsk+1 = xÃÉsk ‚àí Œ≥vks globally and with locks .
8) (End).
9) (Synchronization) Wait for other threads to this step and
then set xÃÉs+1
= xÃÉsm globally.
0

xsj(k) ‚àà {xs1 , xs2 , ¬∑ ¬∑ ¬∑ , xsk }.

(5)

ASVRG-wild
Now we describe ASVRG-wild, which is common in shared
memory multi-core systems. We consider the case where the
x is updated without locks, since the dimension of parameters is often large in real problems. In practice, we only need
to change the steps (4) and (7) in Part II of ASVRG-atom
to
4) read xÃÉ from the global memory without locks.
7) update xÃÉsk+1 = xÃÉsk ‚àí Œ≥vks without locks.
When x is updated without locks, it will cause inconsistent read at the ‚Äúread‚Äù step. Unlike SVRG-atom, the value of
x might not be a real state of x during the ‚Äúread‚Äù step. Since
if one thread reads the x when other thread is updating it, the
thread will receive a ‚Äúmiddle‚Äù state of x. Some coordinates
of x have been updated, while others have not. We still use
xsj(k) to denote the state of x which is at the ‚Äúread‚Äù time during the k-th iteration and is used for calculating the gradient.
In this time, xsj(k) might not belong to {xs1 , xs2 , ¬∑ ¬∑ ¬∑ , xsk }.
However, though x does not work as an atom, the update
on a single coordinate can be considered to be atomic on
GPU and Data Processing System (Niu et al. 2011), (Lian
et al. 2015). To characterize this asynchronous implementation, (Lian et al. 2015) then deÔ¨Åne the update on each single
coordinate of x and assume that the update order is random.
They Ô¨Ånally model the wild update as a Stochastic Coordinate Descent process. We do not follow their assumption.

796

for some œÅ1 > 1 and œÅ2 > 1, then for any s ‚â• 0 and k ‚â• 0,
we have




E ‚àáf (xsk )2 + L2 E xsk ‚àí xs0 2
 



‚â§ œÅ1 E ‚àáf (xsk+1 )2 + L2 E xsk+1 ‚àí xs0 2 ,(11)

We still deÔ¨Åne the update on the whole vector x and directly
represent xsj(k) . Since the update on a single coordinate is
atomic, we have
xsj(k) = xsk ‚àí

k‚àí1




s
,
Œ≥Ik(l) vj(l)

(6)

and

l=1

where Ik(l) is an R ‚Üí R function, indicating whether the
s
elements of vj(l)
have been returned from the local memory
and written into x at the ‚Äúread‚Äù step in the k-th iteration and
s
(p) is the
d is the dimension of the variable x. Suppose vj(l)
s
p-th element of vj(l) with p ranging from 1 to d. We have
d

d


s
 s 
(p) has been returned,
0,
if vj(l)
Ik(l) vj(l)
(p) =
s
vj(l)
(p), otherwise.

‚â§

For ASVRG-atom, œÅ2 can be set as œÅœÑ1 if Eq. (11) is satisÔ¨Åed, since xsj(k) is some old value of xsk . However, for
ASVRG-wild, it is not true. The proof of Lemma 1 has
two major
First, we analyse E ‚àáf (xsk )2 +

 s distinctions.
2
s 2
L E xk ‚àí x0  , while the others (Liu et al. 2015),
(Hsieh, Yu,
 and Dhillon
 2015), (Peng et al. 2015) only consider E ‚àáf (x)2 directly. Second, unlike (Lian et al.
2015), (Liu et al. 2015), (Hsieh, Yu, and Dhillon 2015), the
update in our algorithm is deÔ¨Åned on the whole vector x and
our result does not depend on the dimension of the variable.
This is because that we use Eq. (8) to represent xsj(k) and


carefully bound E xsk ‚àí xsj(k) 2 in the proof. Lemma 1
is the key result for analysing the convergence properties.
Now we demonstrate the convergence results. It uses the
technique of the proof in serial SVRG (Reddi et al. 2016).
The general results are shown in Theorems 1 and 2. We Ô¨Årst
consider the case when ASVRG can achieve linear speed up.

(7)

Then in this way, ASVRG-wild can also be formulated as
in Algorithm 2. One can Ô¨Ånd that Eq. (5) is actually a simply case of Eq. (6). So the difference between ASVRG-atom
and ASVRG-wild is that xsj(k) satisÔ¨Åes both Eq. (5) and
Eq. (6) in ASVRG-atom, while xsj(k) only satisÔ¨Åes Eq. (6)
in ASVRG-wild. By using Eq. (6), we provide a uniÔ¨Åed convergence analysis for the two algorithm.

Convergence Analysis
In this section, we give a uniÔ¨Åed convergence analysis for
ASVRG-atom and ASVRG-wild. It mainly consists of three
parts. We Ô¨Årst bound the variance of gradient in Lemma 1.
Then we analyse the convergence rate in two cases. The Ô¨Årst
case ensures ASVRG to achieve linear speed up. In the second case, we analyse the convergence rate with no assumptions. The proofs can be found in Supplementary Material2 .
The most important value in the analysis of asynchronous
algorithms is the delay parameter œÑ . We deÔ¨Åne that all the
updates before the (k ‚àí œÑ ‚àí 1)-th iteration have been written
into x at the ‚Äúread‚Äù step of the k-th iteration. Thus Eq. (6)
can be rewritten as:
k‚àí1



s
xsj(k) = xsk ‚àí
Œ≥Ik(l) vj(l)
.
(8)

Theorem 1. Suppose fi (i ‚àà {1, 2, ¬∑ ¬∑ ¬∑ , n}) have LLipschitz continuous gradients,Œ± and x is updated as in AlŒº
gorithm 2. Assume that œÑ ‚â§ n 2 (0 < Œ± ‚â§ 1). Set Œ≥ = Ln
Œ±
1
with 0 < Œº ‚â§ 8(e‚àí1)e
and m = n3Œ±/2 . Then we have
S‚àí1 m‚àí1
 nŒ± (f (x00 ) ‚àí f (x‚àó ))
1  
, (13)
E ‚àáf (xsk )2 ‚â§
K s=0
KŒΩ
k=0

where K = mS, ŒΩ =
of f (x).

l=k‚àíœÑ

œÑ actually indicates the number of processors that are involved in computation. From Algorithm 2, we have 1 ‚â§ œÑ ‚â§
m.
To prove convergence, we need to bound the variance of
the gradient. In ASVRG, Eq. (4) changes to
 s





E vj(k)
2 ‚â§ E ‚àáf (xsj(k) 2 +L2 E xsj(k) ‚àí xs0 2 .

Then Lemma 1 builds the relation between

xsj(k)

and

1
3 Œº,

and f (x‚àó ) is the minimal value

We rewrite the above results in terms of IFO calls in the
following corollary. The IFO calls have included the n IFO
calls to compute the full gradient for every m iterations.
Corollary 1. Suppose fi (i ‚àà {1, 2, ¬∑ ¬∑Œ±¬∑ , n}) have LLipschitz continuous gradients and œÑ ‚â§ n 2 (0 < Œ± ‚â§ 1).
With the parameters in Theorem 1, the IFO complexity of
Algorithm 2 for achieving an -accurate solution is:


Œ±
IFO calls = O nmax(Œ±,1‚àí 2 ) / .
(14)

(9)

xsk .

Lemma 1. Suppose fi (i ‚àà {1, 2, ¬∑ ¬∑ ¬∑ , n}) have L-Lipschitz
continuous gradients, and x is updated as in Algorithm 2.
Then if the step size Œ≥ satisÔ¨Åes
‚éß
‚é´
‚é™
‚é™
‚é®
‚é¨
1
œÅ1 ‚àí 1
œÅ2 ‚àí 1
‚àö ‚àö ,
Œ≥ ‚â§ min
, (10)
œÑ
L‚é™
‚é© 2 2œÅ1 œÅ2 2‚àö2œÅ 12 œÅ 32 ‚àöœÅ12 ‚àí1 ‚é™
‚é≠
1 2 œÅ1 ‚àí1
2
Supplementary Material can be downloaded
http://www.cis.pku.edu.cn/faculty/vision/zlin/zlin.htm





E ‚àáf (xsj(k) )2 + L2 E xsj(k) ‚àí xs0 2
 



œÅ2 E ‚àáf (xsk )2 + L2 E xsk ‚àí xs0 2 . (12)

Corollary 1 demonstrates the interplay between the step
size and the IFO complexity. The result is similar to the serial SVRG (Reddi et al. 2016). When œÑ ‚â§ n1/3 , thenumber

2/3
of IFO calls is minimized when Œ± = 2/3 and it is O n  .
This shows that ASVRG can achieve linear speed up (to the
stationary point) when œÑ ‚â§ n1/3 .
Now we demonstrate the result with no assumption on œÑ .

from:

797

Theorem 2. Suppose fi (i ‚àà {1, 2, ¬∑ ¬∑ ¬∑ , n}) have LLipschitz continuous gradients, and x is updated as in Algo1
, 0 < Œ± ‚â§ 1,
rithm 2. Set Œ≥ = Œº/(LnŒ± œÑ Œ≤ ) (0 < Œº ‚â§ 8(e‚àí1)e
and 0 < Œ≤ ‚â§ 1) and m = n

3Œ±
2

œÑ

3Œ≤‚àí1
2

Experiments
In this section, we conduct experiments on a shared memory multi-core system to validate the efÔ¨Åciency of our algorithm empirically. We directly show the experimental results of ASVRG-wild as it is faster and more suitable for the
shared memory multi-core system. We also test the speedup
property of ASVRG-atom, which is shown in Supplementary Material. Due to the locks, it is slower than ASVRGwild. Our experiments consist of two parts. The Ô¨Årst part
aims to validate the speedup property. In the second part,
we do a similar experiment to that in (Lian et al. 2015) to
compare our algorithm with ASGD to show the superiority
of our algorithm in speed. Since the advantages in speed for
asynchronous algorithms over synchronous algorithms have
been widely witnessed in many literatures (Hsieh, Yu, and
Dhillon 2015), (Agarwal and Duchi 2011), (Niu et al. 2011),
we ignore the experiment of comparing our algorithm with
synchronous SVRG. Due to much more locks, synchronous
SVRG is slower than ASVRG-atom. For a fair comparison,
we implement all methods in C++ using POSIX threads as
the parallel programming framework. All the experiments
are performed on an Intel multi-core 4-socket machine with
128 GB memory. Each socket is associated with 8 computation cores. A variant that we adopt in experiments is that we
implement all the algorithms in a mini-batch mode, which is
a common implementation in neural networks. The convergence analysis for ASVRG can be extended to this mode.
Following (Lian et al. 2015), we focus on two types of
speedup: iteration speedup and running time speedup. The
iteration speedup is exactly the speedup we discussed in the
whole paper. Given T workers, it is computed as

. Then we have

S‚àí1 m‚àí1

nŒ± œÑ Œ≤ (f (x00 ) ‚àí f (x‚àó ))
1  
E ‚àáf (xsk )2 ‚â§
,
K s=0
KŒΩ

(15)

k=0

where K = mS and ŒΩ = 13 Œº.
Corollary 2. Suppose fi (i ‚àà {1, 2, ¬∑ ¬∑ ¬∑ , n}) have LLipschitz continuous gradients. With the parameters in Theorem 2, the IFO complexity of Algorithm 2 for achieving an
-accurate solution is:


1‚àíŒ≤
Œ±
(16)
IFO calls = O nmax(Œ±,1‚àí 2 ) œÑ max(Œ≤, 2 ) / .
From Corollary 2, the number of IFO 
calls is minimized

2/3 1/3
when Œ± = 23 and Œ≤ = 13 , which is O n œÑ
. Since
œÑ ‚â§ m = n, n2/3 œÑ 1/3 ‚â§ n. This shows that with asynchronous updating, SVRG still has a less number of IFOs
when compared with GD.
The following theorem gives a probability estimate on the
convergence of Algorithm 2.
Theorem 3. Suppose fi (i ‚àà {1, 2, ¬∑ ¬∑ ¬∑ , n}) have LLipschitz continuous gradients, and x is updated as in Algorithm 2. Then for  > 0 and Œ∑ ‚àà (0, 1) and K = Sm, we
have the probability

 S‚àí1 m‚àí1
1 
s 2
‚àáF (xk ) ‚â§  ‚â• 1 ‚àí Œ∑,
(17)
P
K s=0

iteration speedup =

k=0

provided that one of the following conditions holds: when
œÑ ‚â§ nŒ±/2 , we require


nŒ± F (x0 ) ‚àí F (x‚àó )
,
(18)
K‚â•
ŒΩŒ∑

where # is the iteration count when the same level of precision is achieved. This speedup is less affected by the hardware. The running time speedup is the actual speedup. It is
deÔ¨Åned as:
running time speedup =

and the parameters are chosen as in Theorem 1, while there
is no assumption on œÑ , we need


nŒ± œÑ Œ≤ F (x0 ) ‚àí F (x‚àó )
,
(19)
K‚â•
ŒΩŒ∑

total running time using one worker
.
total running time using T workers

The running time speedup is seriously affected by the hardware. It is less objective than the iteration speedup.

Speedup Experiment

and the parameters are chosen as in Theorem 2.

We experiment on the problem of multiclass classiÔ¨Åcation
using neural networks. It is a typical nonconvex problem in
machine learning.
Experimental Setup. Following (Reddi et al. 2016), we
train a neural network with one fully connected layer of 100
nodes. We experiment on two dataset: MNIST dataset3 and
CIFAR10 dataset (Krizhevsky and Hinton 2009). Both the
two datasets have ten classes. They are widely used for testing neural networks. More details about the datasets can be
found in Table 2. The data are normalized to the interval
[0, 1] before the experiment. An additional experiment in

Distinguished from the analysis of ASGD (Lian et al.
2015), we do not assume that the update order on coordinates is random in the ‚Äúwild‚Äù scheme and give uniÔ¨Åed proofs
for the two schemes.For ASGD, the convergence rate is
only an asymptotic O 12 . We show that with the VR trick,
2

ASGD can be accelerated to a non-asymptotic O( n3 ) con1

# of itertions using one worker
√ó T,
# of iterations using T workers

2

1

vergence rate when œÑ ‚â§ n 3 and a non-asymptotic O( n 3œÑ 3 )
convergence rate where there is no assumption on œÑ . When
compared with the serial SVRG, ASVRG can achieve linear
1
speed up when œÑ ‚â§ n 3 and also has less number of IFOs
than GD when there is no assumption on œÑ .

3

798

http://yann.lecun.com/exdb/mnist/

0.32

0.16

0.08

0.64

0.32

1-core SVRG
4-core SVRG
8-core SVRG
12-core SVRG
16-core SVRG
20-core SVRG
1-core SGD
12-core SGD

1.8
1.6
1.4

0.16

1.2
1

0.8

0.6

2

1-core SVRG
4-core SVRG
8-core SVRG
12-core SVRG
16-core SVRG
20-core SVRG

1.8
1.6
1.4

tranning loss (log)

0.64

2.2

2

1-core SVRG
4-core SVRG
8-core SVRG
12-core SVRG
16-core SVRG
20-core SVRG

1.28

tranning loss (log)

tranning loss (log)

1.28

2.2

3
2.56

1-core SVRG
4-core SVRG
8-core SVRG
12-core SVRG
16-core SVRG
20-core SVRG
1-core SGD
12-core SGD

tranning loss (log)

3
2.56

1.2
1

0.8

0.6

0.08

0.4

0.04

0.4

0.04

10

20

30

40

50

60

500

1000

iteration/n

1500

2000

2500

10

3000

30

40

50

60

1000

2000

3000

4000

iteration/n

time(s)

(a) Loss vs. iteration on MNIST

20

(b) Loss vs. time on MNIST

5000

6000

7000

8000

9000

10000

time(s)

(c) Loss vs. iteration on CIFAR10

(d) Loss vs. time on CIFAR10

Figure 1: Results of the speedup experiment. For curves of loss against iterations, the horization axis is the number of effective
pass through the data, which has included the cost of calculating full gradients for SVRG.
thetic data from a fully connected neural network with 5
layers (400 √ó 100 √ó 50 √ó 20 √ó 10) and 46, 380 parameters totally. The input vector and all parameters are generated from N (0, 1) Gaussian distribution. The output vector
is constructed by applying the network parameter to the input vector plus some Gaussian random noise. We generate
40, 000 samples.
Like (Lian et al. 2015), we focus on 2 norm of the gradients. The parameters in the two algorithms are tuned on
12 cores to give the best results. For ASGD, we choose the
mini-batch size to be 50, and the step size to be 10‚àí4 , which
we Ô¨Ånd is better than the setting used in (Lian et al. 2015).
Figure 2 draws the curves of ‚àáf (x)2 against running
time using 8, 12, 20 cores, respectively. Like serial SVRG,
ASVRG is not faster at the early stage when compared with
ASGD. But after dozens of epochs, the norm of gradient by
ASVRG decreases faster. This demonstrates that ASVRG
has a faster convergence rate than ASGD does.

Table 2: More details about MNIST and CIFAR10.
Datasets
MNIST
CIFAR10

Type
28 √ó 28 grayscale
32 √ó 32 RGB

# Images
60K
50K

# Params
79.5K
308.3K

Table 3: Iteration and running time speedup over SVRG on
MNIST and CIFAR10. (Thr- and Iter, are short for thread
and iteration, respectively.).
Mnist
Cifar

iter.
time
iter.
time

thr-1
1
1
1
1

thr-4
3.94
3.59
4.01
3.96

thr-8
7.55
6.47
7.92
6.87

thr-12
11.85
9.97
12.15
10.31

thr-16
15.53
11.44
15.59
13.02

thr-20
19.28
12.58
19.31
14.53

which we train a neural network with 7 layers on MNIST
is shown in Supplementary Material.
Parameters and Initialization. For SVRG, we choose a
Ô¨Åxed step size, and choose Œ≥ that gives the best performance
on one core. When there are more than one core, the step size
does not change. For SGD, the step size is chosen based on
(Reddi et al. 2016), which is Œ≥t = Œ≥0 (1+Œ≥  t/n)‚àí1 , where
Œ≥0 and Œ≥  are chosen to give the best performance. We use
the normalized initialization in (Glorot and Bengio 2010),
(Reddi etal. 2016). Theparameters are chosen uniformly
from [‚àí 6/(ni + no ), 6/(ni + no )], where ni and no
are the numbers of input and output layers of the neural networks, respectively. We choose a mini-batch size to be 100,
which is a common setting in training neural networks.
Results. We draw the curves of objective loss against iterations and running time in Figure 1, and report their speedup
in Table 3. From the results, we obtain the following conclusions. First, the linear speedup is achievable through iteration speedup. Second, due to the hardware, time speedup
is lower than iteration speedup. Third, ASVRG still has an
obvious actual (time) speedup when compared with serial
SVRG, e.g., there are 12 times speedup on 20 cores.

Conclusion
This paper proposes an asynchronous variant of SVRG on
nonconvex problems. We give the condition on the delay parameter œÑ to make the asynchronous algorithm achieve linear speed up. We also analyse the convergence rate with no
assumption on œÑ . We experiment on a shared memory multicore system to demonstrate the efÔ¨Åciency of the proposed
ASVRG algorithm.

Acknowledgements
Zhouchen Lin is supported by National Basic Research Program of China (973 Program) (grant no. 2015CB352502),
National Natural Science Foundation (NSF) of China (grant
nos. 61625301 and 61231002), and Qualcomm.

References
Agarwal, A., and Duchi, J. C. 2011. Distributed delayed
stochastic optimization. In Proc. Conf. Advances in Neural
Information Processing Systems.
Allen-Zhu, Z., and Hazan, E. 2016. Variance reduction for
faster non-convex optimization. In Proc. Int‚Äôl. Conf. on Machine Learning.
Dean, J.; Corrado, G.; Monga, R.; Chen, K.; Devin, M.;
Mao, M.; Senior, A.; Tucker, P.; Yang, K.; Le, Q. V.; et al.

EfÔ¨Åciency Validation
To demonstrate the efÔ¨Åciency of our ASVRG, we do a similar experiment to that in (Lian et al. 2015) to compare with
ASGD. Following (Lian et al. 2015), we generate the syn-

799

10 1

10 -1

10 -1

10 -2

10 -4
10 -5

10

 

-3

-3

10 -4
10 -5

10 -3
10 -4
10 -5

10 -6

10 -6

10 -6

-7

-7

10 -7

10 -8

10 -8

10 -8

10 -9

10 -9

10

10

500

1000

1500

2000

2500

3000

3500

20-core SGD
20-core SVRG

10 0
10 -1

10 -2

 

 

12-core SGD
12-core SVRG

10 0

10 -2

10

10 1

10 1

8-core SGD
8-core SVRG

10 0

200

400

600

800

time(s)

1000

1200

1400

time(s)

1600

1800

2000

2200

2400

10 -9

200

400

600

800

1000

1200

1400

time(s)

Figure 2: Experimental results of efÔ¨Åciency validation. The Ô¨Ågures from left to right represent the results on 8, 12, and 20 cores,
respectively.
2012. Large scale distributed deep networks. In Proc. Conf.
Advances in Neural Information Processing Systems.
Defazio, A.; Bach, F.; and Lacoste-Julien, S. 2014. SAGA:
A fast incremental gradient method with support for nonstrongly convex composite objectives. In Proc. Conf. Advances in Neural Information Processing Systems.
Ghadimi, S., and Lan, G. 2013. Stochastic Ô¨Årst-and
zeroth-order methods for nonconvex stochastic programming. SIAM Journal on Optimization 23(4):2341‚Äì2368.
Glorot, X., and Bengio, Y. 2010. Understanding the difÔ¨Åculty of training deep feedforward neural networks. In Proc.
Int‚Äôl. Conf. on ArtiÔ¨Åcaial Intelligence and Statistics.
Hsieh, C.-J.; Yu, H.-F.; and Dhillon, I. S. 2015. PASSCoDe:
Parallel asynchronous stochastic dual co-ordinate descent.
In Proc. Int‚Äôl. Conf. on Machine Learning.
Johnson, R., and Zhang, T. 2013. Accelerating stochastic gradient descent using predictive variance reduction. In
Proc. Conf. Advances in Neural Information Processing Systems.
Krizhevsky, A., and Hinton, G. 2009. Learning multiple
layers of features from tiny images. Computer Science Department, University of Toronto, Technical Report 1(4):7.
Lian, X.; Huang, Y.; Li, Y.; and Liu, J. 2015. Asynchronous
parallel stochastic gradient for nonconvex optimization. In
Advances in Neural Information Processing Systems.
Liu, J.; Wright, S. J.; ReÃÅ, C.; Bittorf, V.; and Sridhar, S. 2015.
An asynchronous parallel stochastic coordinate descent algorithm. Journal of Machine Learning Research 16(285322):1‚Äì5.
Nesterov, Y. 2013. Introductory lectures on convex optimization: A basic course, volume 87. Springer Science &
Business Media.
Niu, F.; Recht, B.; Re, C.; and Wright, S. 2011. HOGWILD!: A lock-free approach to parallelizing stochastic gradient descent. In Proc. Conf. Advances in Neural Information Processing Systems.
Paine, T.; Jin, H.; Yang, J.; Lin, Z.; and Huang, T. 2013. Gpu
asynchronous stochastic gradient descent to speed up neural
network training. arXiv preprint arXiv:1312.6186.

Peng, Z.; Xu, Y.; Yan, M.; and Yin, W. 2015. Arock: an
algorithmic framework for asynchronous parallel coordinate
updates. arXiv preprint arXiv:1506.02396.
Petroni, F., and Querzoni, L. 2014. Gasgd: stochastic gradient descent for distributed asynchronous matrix completion
via graph partitioning. In Proc. ACM Conf. on Recommender
Systems, 241‚Äì248. ACM.
Reddi, S. J.; Hefny, A.; Sra, S.; PoÃÅczoÃÅs, B.; and Smola, A.
2015. On variance reduction in stochastic gradient descent
and its asynchronous variants. In Proc. Conf. Advances in
Neural Information Processing Systems.
Reddi, S. J.; Hefny, A.; Sra, S.; PoÃÅczoÃÅs, B.; and Smola, A.
2016. Stochastic variance reduction for nonconvex optimization. In Proc. Int‚Äôl. Conf. on Machine Learning.
Schmidt, M.; Roux, N. L.; and Bach, F. 2013. Minimizing Ô¨Ånite sums with the stochastic average gradient. arXiv
preprint arXiv:1309.2388.
Xiao, L., and Zhang, T. 2014. A proximal stochastic gradient
method with progressive variance reduction. SIAM Journal
on Optimization 24(4):2057‚Äì2075.
Yun, H.; Yu, H.-F.; Hsieh, C.-J.; Vishwanathan, S.; and
Dhillon, I. 2014. NOMAD: Non-locking, stOchastic Multimachine algorithm for Asynchronous and Decentralized matrix completion. Proc. of VLDB Endowment 7(11):975‚Äì986.
Zhang, R., and Kwok, J. T. 2014. Asynchronous distributed
ADMM for consensus optimization. In Proc. Int‚Äôl. Conf. on
Machine Learning.

800

