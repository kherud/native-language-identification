Hybrid Grammars for Parsing of
Discontinuous Phrase Structures and
Non-Projective Dependency Structures
Kilian Gebhardt∗
Technische Universität Dresden

Mark-Jan Nederhof∗∗
University of St. Andrews

Heiko Vogler∗
Technische Universität Dresden

We explore the concept of hybrid grammars, which formalize and generalize a range of existing
frameworks for dealing with discontinuous syntactic structures. Covered are both discontinuous
phrase structures and non-projective dependency structures. Technically, hybrid grammars are
related to synchronous grammars, where one grammar component generates linear structures
and another generates hierarchical structures. By coupling lexical elements of both components
together, discontinuous structures result. Several types of hybrid grammars are characterized. We
also discuss grammar induction from treebanks. The main advantage over existing frameworks
is the ability of hybrid grammars to separate discontinuity of the desired structures from time
complexity of parsing. This permits exploration of a large variety of parsing algorithms for
discontinuous structures, with different properties. This is confirmed by the reported experimental
results, which show a wide variety of running time, accuracy, and frequency of parse failures.
1. Introduction
Much of the theory of parsing assumes syntactic structures that are trees, formalized
such that the children of each node are ordered, and the yield of a tree, that is, the leaves
read from left to right, is the sentence. In different terms, each node in the hierarchical
syntactic structure of a sentence corresponds to a phrase that is a list of adjacent words,
without any gaps. Such a structure is easy to represent in terms of bracketed notation,
which is used, for instance, in the Penn Treebank (Marcus, Santorini, and Marcinkiewicz
1993).

∗ Department of Computer Science, Technische Universität Dresden, D-01062 Dresden, Germany.
E-mail: {kilian.gebhardt, heiko.vogler}@tu-dresden.de.
∗∗ School of Computer Science, University of St. Andrews, North Haugh, St. Andrews, KY16 9SX, UK.
Submission received: 19 November 2015; revised version received: 11 November 2016; accepted for publication:
22 December 2016.
doi:10.1162/COLI_a_00291
© 2017 Association for Computational Linguistics
Published under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International
(CC BY-NC-ND 4.0) license

Computational Linguistics

Volume 43, Number 3

Describing syntax in terms of such narrowly defined trees seems most appropriate for
relatively rigid word-order languages such as English. Nonetheless, the aforementioned
Penn Treebank of English contains traces and other elements that encode additional
structure next to the pure tree structure as indicated by the brackets. This is in keeping
with observations that even English cannot be described adequately without a more
general form of trees, allowing for so-called discontinuity (McCawley 1982; Stucky 1987).
In a discontinuous structure, the set of leaves dominated by a node of the tree need not
form a contiguous sequence of words, but may comprise one or more gaps. The need for
discontinuous structures tends to be even greater for languages with relatively free word
order (Kathol and Pollard 1995; Müller 2004).
In the context of dependency parsing (Kübler, McDonald, and Nivre 2009), the
more specific term non-projectivity is used instead of, or next to, discontinuity. See
Rambow (2010) for a discussion of the relation between constituent and dependency
structures and see Maier and Lichte (2009) for a comparison of discontinuity and nonprojectivity. As shown by, for example, Hockenmaier and Steedman (2007) and Evang
and Kallmeyer (2011), discontinuity encoded using traces in the Penn Treebank can be
rendered in alternative, and arguably more explicit, forms. In many modern treebanks,
discontinuous structures have been given a prominent status (e.g., Böhmová et al. 2000).
Figure 1 shows an example of a non-projective dependency structure.
The most established parsing algorithms are compiled out of context-free grammars
(CFGs), or closely related formalisms such as tree substitution grammars (Sima’an
et al. 1994) or regular tree grammars (Brainerd 1969; Gécseg and Steinby 1997). These
parsers, which have a time complexity of O(n3 ) for n being the length of the input string,
operate by composing adjacent substrings of the input sentence into longer substrings.
As a result, the structures they can build directly do not involve any discontinuity. The
need for discontinuous syntactic structures thus poses a challenge to traditional parsing
algorithms.
One possible solution is commonly referred to as pseudo-projectivity in the literature on dependency parsing (Kahane, Nasr, and Rambow 1998; Nivre and Nilsson
2005; McDonald and Pereira 2006). A standard parsing system is trained on a corpus of
projective dependency structures that was obtained by applying a lifting operation to
non-projective structures. In a first pass, this system is applied to unlabeled sentences
and produces projective dependencies. In a second pass, the lifting operation is reversed
to introduce non-projectivity. A related idea for discontinuous phrase structures is the
reversible splitting conversion of Boyd (2007). See also Johnson (2002), Campbell (2004),
and Gabbard, Kulick, and Marcus (2006).
The two passes of pseudo-projective dependency parsing need not be strictly
separated in time. For example, one way to characterize the algorithm by Nivre (2009)
is that it combines the first pass with the second. Here the usual one-way input tape
is replaced by a buffer. A non-topmost element from the parsing stack, which holds a
word previously read from the input sentence, can be transferred back to the buffer, and

0 ROOT 1 A 2 hearing 3 is 4 scheduled 5 on 6 the 7 issue 8 today

Figure 1
A non-projective dependency structure.

466

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

thereby input positions can be effectively swapped. This then results in a non-projective
dependency structure.
A second potential solution to obtain syntactic structures that go beyond context-free
power is to use more expressive grammatical formalisms. One approach proposed by
Reape (1989, 1994) is to separate linear order from the parent–child relation in syntactic
structure, and to allow shuffling of the order of descendants of a node, which need
not be its direct children. The set of possible orders is restricted by linear precedence
constraints. A further restriction may be imposed by compaction (Kathol and Pollard
1995). As discussed by Fouvry and Meurers (2000) and Daniels and Meurers (2002),
this may lead to exponential parsing complexity; see also Daniels and Meurers (2004).
Separating linear order from the parent–child relation is in the tradition of headdriven phrase structure grammar (HPSG), where grammars are commonly hand-written.
This differs from our objectives to induce grammars automatically from training data,
as will become clear in the following sections.
To stay within a polynomial time complexity, one may also consider tree adjoining
grammars (TAGs), which can describe strictly larger classes of word order phenomena
than CFGs (Rambow and Joshi 1997). The resulting parsers have a time complexity of
O(n6 ) (Vijay-Shankar and Joshi 1985). However, the derived trees they generate are still
continuous. Although their derivation trees may be argued to be discontinuous, these by
themselves are not normally the desired syntactic structures. Moreover, it was argued by
Becker, Joshi, and Rambow (1991) that further additions to TAGs are needed to obtain
adequate descriptions of certain non-context-free phenomena. These additions further
increase the time complexity.
In order to obtain desired syntactic structures, one may combine TAG parsing with an
idea that is related to that of pseudo-projectivity. For example, Kallmeyer and Kuhlmann
(2012) propose a transformation that turns a derivation tree of a (lexicalized) TAG into a
non-projective dependency structure. The same idea has been applied to derivation trees
of other formalisms, in particular (lexicalized) linear context-free rewriting systems
(LCFRSs) (Kuhlmann 2013), whose weak generative power subsumes that of TAGs.
Parsers more powerful than those for CFGs often incur high time costs. In particular,
LCFRS parsers have a time complexity that is polynomial in the sentence length, but with
a degree that is determined by properties of the grammar. This degree typically increases
with the amount of discontinuity in the desired structures. Difficulties in running LCFRS
parsers for natural languages are described, for example, by Kallmeyer and Maier (2013).
In the architectures we have discussed, the common elements are:

r
r

a grammar, in some fixed formalism, that determines the set of sentences
that are accepted, and
a procedure to build (discontinuous) structures, guided by the derivation of
input sentences.

The purpose of this article is to explore a theoretical framework that allows us to capture
a wide range of parsing architectures that all share these two common elements. At the
core of this framework lies a formalism called hybrid grammar, introduced in Nederhof
and Vogler (2014). Such a grammar consists of a string grammar and a tree grammar.
Derivations are coupled, as in synchronous grammars (Shieber and Schabes 1990; Satta
and Peserico 2005). In addition, each occurrence of a terminal symbol in the string
grammar is coupled to an occurrence of a terminal symbol in the tree grammar. The string
grammar defines the set of accepted sentences. The tree grammar, whose rules are tied

467

Computational Linguistics

Volume 43, Number 3

is
hearing

scheduled
on

A

today
issue
the

A

hearing

is

scheduled

on

the

issue

today

Figure 2
A hybrid tree corresponding to the non-projective dependency structure of Figure 1.

to the rules of the string grammar for synchronous rewriting, determines the resulting
syntactic structures, which may be discontinuous. The way the syntactic structures are
obtained critically relies on the coupling of terminal symbols in the two component
grammars, which is where our theory departs from that of synchronous grammars. A
hybrid grammar generates a set of hybrid trees;1 Figure 2 shows an example of a hybrid
tree, which corresponds to the non-projective dependency structure of Figure 1.
The general concept of hybrid grammars leaves open the choice of the string
grammar formalism and that of the tree grammar formalism. In this article we consider
simple macro grammars (Fischer 1968) and LCFRSs as string grammar formalisms.
The tree grammar formalisms we consider are simple context-free tree grammars
(Rounds 1970) and simple definite clause programs (sDCP), inspired by Deransart and
Małuszynski (1985). This gives four combinations, each leading to one class of hybrid
grammars. In addition, more fine-grained subclasses can be defined by placing further
syntactic restrictions on the string and tree formalisms.
To place hybrid grammars in the context of existing parsing architectures, let us
consider classical grammar induction from a treebank, for example, for context-free
grammars (Charniak 1996) or for LCFRSs (Maier and Søgaard 2008; Kuhlmann and Satta
2009). Rules are extracted directly from the trees in the training set, and unseen input
strings are consequently parsed according to these structures. Grammars induced in this
way can be seen as restricted hybrid grammars, in which no freedom exists in the relation
between the string component and the tree component. In particular, the presence of
discontinuous structures generally leads to high time complexity of string parsing. In
contrast, the framework in this article detaches the string component of the grammar
from the tree component. Thereby the parsing process of input strings is no longer bound
to follow the tree structures, while the same tree structures as before can still be produced,
provided the tree component is suitably chosen. This allows string parsing with low time
complexity in combination with production of discontinuous trees.
Nederhof and Vogler (2014) presented experiments with various subclasses of hybrid
grammars for the purpose of constituent parsing. Trade-offs between speed and accuracy

1 The term “hybrid tree” was used before by Lu et al. (2008), also for a mixture of a tree structure and a linear
structure, generated by a probabilistic model. However, the linear “surface” structure was obtained by a
simple left-to-right tree traversal, whereas a meaning representation was obtained by a slightly more
flexible traversal of the same tree. The emphasis in the current article is rather on separating the linear
structure from the tree structure. Note that similar distinctions of multiple strata were made before in both
constituent linguistics (see, e.g., Chomsky 1981) and dependency linguistics (see, e.g., Mel’čuk 1988).

468

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

were identified. In the present article, we extend our investigation to dependency parsing.
This includes induction of a hybrid grammar from a dependency treebank. Before turning
to the experiments, we present several completeness results about existence of hybrid
grammars generating non-projective dependency structures.
This article is organized as follows. After preliminaries in Section 2, Section 3 defines
hybrid trees. These are able to capture both discontinuous phrase structures and nonprojective dependency structures. Thanks to the concept of hybrid trees, there will be no
need, later in the article, to distinguish between hybrid grammars for constituent parsing
and hybrid grammars for dependency parsing. To make this article self-contained, we
define two existing string grammar formalisms and two tree grammar formalisms in
Section 4. The four classes of hybrid grammars that result by combining these formalisms
are presented in Section 5, which also discusses how to use them for parsing.
How to induce hybrid grammars from treebanks is discussed in Section 6. Section 7
reports on experiments that provide proof of concept. In particular, LCFRS/sDCP-hybrid
grammars are induced from corpora of dependency structures and phrase structures and
employed to predict the syntactic structure of unlabeled sentences. It is demonstrated
that hybrid grammars allow a wide variety of results, in terms of time complexity,
accuracy, and frequency of parse failures. How hybrid grammars relate to existing ideas
is discussed in Section 8.
The text refers to a number of theoretical results that are not central to the main
content of this article. In order to preserve the continuity of the discussion, we have
deferred their proofs to appendices.
2. Preliminaries
Let N = {0, 1, 2, . . .} and N+ = N \ {0}. For each n ∈ N+ , we let [n] stand for the set
{1, . . . , n}, and we let [0] stand for ∅. We write [n]0 to denote [n] ∪ {0}. We fix an
infinite list x1 , x2 , . . . of pairwise distinct variables. We let X = {x1 , x2 , x3 , . . .} and
Xk = {x1 , . . . , xk } for each k ∈ N. For any set A, the power set of A is denoted by P (A).
A ranked set ∆ is a set of symbols associated with a rank function assigning a
number rk∆ (δ ) ∈ N to each symbol δ ∈ ∆. A ranked alphabet is a ranked set with a
finite number of symbols. We let ∆(k) denote {δ ∈ ∆ | rk∆ (δ ) = k}.
The following definitions were inspired by Seki and Kato (2008). The sets of terms
and sequence-terms (s-terms) over ranked set ∆, with variables in some set Y ⊆ X, are
∗
denoted by T∆ (Y) and T∆
(Y), respectively, and defined inductively as follows:
(i)
(ii)
(iii)

Y ⊆ T∆ (Y),
∗
if k ∈ N, δ ∈ ∆(k) and si ∈ T∆
(Y) for each i ∈ [k], then δ(s1 , . . . , sk ) ∈ T∆ (Y),
and
∗
if n ∈ N and ti ∈ T∆ (Y) for each i ∈ [n], then ht1 , . . . , tn i ∈ T∆
(Y).

∗
∗
We let T∆
and T∆ stand for T∆
(∅ ) and T∆ (∅ ), respectively. Throughout this article,
we use variables such as s and si for s-terms and variables such as t and ti for terms.
The length |s| of a s-term s = ht1 , . . . , tn i is n.
The justification for using s-terms as defined here is that they provide the required
flexibility for dealing with both strings and unranked trees, in combination with
derivational nonterminals in various kinds of grammar. By using an alphabet ∆ =
∆(0) one can represent strings. For instance, if ∆ contains the symbols a and b, then the

469

Computational Linguistics

Volume 43, Number 3

s-term ha(), b(), a()i denotes the string a b a. We will therefore refer to such s-terms simply
as strings.
By using an alphabet ∆ = ∆(1) one may represent trees without fixing the number of
child nodes that a node with a certain label should have. Conceptually, one may think of
such node labels as unranked, as is common in parsing theory of natural language. For
instance, the s-term ha(hb(hi ), a(hi )i )i denotes the unranked tree a(b, a). We will therefore
refer to such s-terms simply as trees, and we will sometimes use familiar terminology,
such as “node,” “parent,” and “sibling,” as well as common graphical representations of
trees.
If theoretical frameworks require trees over ranked alphabets in the conventional
sense (without s-terms), one may introduce a distinguished symbol cons of rank 2,
replacing each s-term of length greater than 1 by an arrangement of subterms combined
using occurrences of that symbol. Another symbol nil of rank 0 may be introduced to replace each s-term of length 0. Hence δ(hα(hi ), β(hi ), γ(hi )i ) could be more conventionally
written as δ(cons(α(nil), cons(β(nil), γ(nil)))).
Concatenation of s-terms is given by ht1 , . . . , tn i · htn+1 , . . . , tn+m i = ht1 , . . . , tn+m i.
Sequences such as s1 , . . . , sk or x1 , . . . , xk will typically be abbreviated to s1,k or x1,k ,
respectively. For δ ∈ ∆(0) we sometimes abbreviate δ() to δ.
In examples we also abbreviate ht1 , . . . , tn i to t1 · · · tn —that is, omitting the angle
brackets and commas. In particular, for n = 0, the s-term hi is abbreviated by ε. Moreover,
we sometimes abbreviate δ(hi ) to δ. Whether δ then stands for δ(hi ) or for δ() depends
on whether δ ∈ ∆(1) or δ ∈ ∆(0) , which will be clear from the context.
Subterms in terms or s-terms are identified by positions (cf. Gorn addresses).
The set of all positions in term t or in s-term s is denoted by pos(t) or pos(s), respectively,
and defined inductively by:
pos(x) = {ε}
pos(δ(s1,k )) = {ε} ∪ {ip | i ∈ [k], p ∈ pos(si )}
pos(ht1,n i ) = {ip | i ∈ [n], p ∈ pos(ti )}
Note that a (sub-)s-term does not have a position. We let ≤` denote the lexicographical
order of positions. We say that position p is a parent of position p0 if p0 is of the form
pij, for some numbers i and j, and we denote parent(pij) = p. For a position p0 of length
0 or 1, we set parent(p0 ) = nil. Conversely, the set of children of a position p, denoted
by children(p), contains each position p0 with parent(p0 ) = p. The right sibling of the
position pij, denoted by right-sibling(pij), is pi(j + 1).
The subterm at position p in a term t (or a s-term s) is defined as follows. For any
term t we have t|ε = t. For a term t = δ(s1,k ), i ∈ [k], p ∈ pos(si ) we have t|ip = si |p . For a
s-term s = ht1,n i, i ∈ [n], p ∈ pos(ti ) we have s|ip = ti |p .
The label at position p in a term t is denoted by t(p). In other words, if t|p equals
δ(s1 , . . . , sk ) or x ∈ X, then t(p) equals δ or x, respectively. Let Γ ⊆ ∆. The subset of pos(t)
consisting of all positions where the label is in Γ is denoted by posΓ (t), or formally
posΓ (t) = {p ∈ pos(t) | t(p) ∈ Γ}. Analogously to t(p) and posΓ (t) for terms t, one may
define s(p) and posΓ (s) for s-terms s.
The expression t[s0 ]p (or s[s0 ]p ) denotes the s-term obtained from t (or from s) by
replacing the subterm at position p by s-term s0 . For any term t we have t[s0 ]ε = s0 . For a
term t = δ(s1,k ), i ∈ [k], p ∈ pos(si ) we have t[s0 ]ip = hδ(s1,i−1 , si [s0 ]p , si+1,k )i. For a s-term
s = ht1,n i, i ∈ [n], p ∈ pos(ti ) we have s[s0 ]ip = ht1,i−1 i · ti [s0 ]p · hti+1,n i.
470

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

VP1
A111

C2

B112

C113
D11311

E11312

Figure 3
Illustration of the s-term hVP(hA(hi ), B(hi ), C(hD(hi ), E(hi )i )i ), C(hi )i where positions are
annotated in subscript at each node.

For term t (or s-term s) with variables in Xk and s-terms si (i ∈ [k]), the first-order
substitution t[s1,k ] (or s[s1,k ], respectively) denotes the s-term obtained from t (or from s)
by replacing each occurrence of any variable xi by si , or formally:

r
r
r

xi [s1,k ] = si ,

δ(s01,n )[s1,k ] = hδ(s01 [s1,k ], . . . , s0n [s1,k ])i,
ht1,n i[s1,k ] = t1 [s1,k ] · . . . · tn [s1,k ].

∗
∗
If s ∈ T∆
, s|p = δ(s1,k ) and s0 ∈ T∆
(Xk ), then the second-order substitution sJs0 Kp
denotes the s-term obtained from s by replacing the subterm at position p by s0 , with
the variables in s0 replaced by the corresponding s-terms found immediately below p, or
formally sJs0 Kp = s[s0 [s1,k ]]p .

Example 1
Consider ∆ = {A, B, C, α, β, γ1 , γ2 , δ1 , δ2 } where rk∆ (A) = 0, rk∆ (B) = rk∆ (C) = 2, and
∗
all other symbols have rank 1. An example of a s-term in T∆
(X2 ) is s = α(A()) x2 B(x1 , β ),
which is short for:

hα(hA()i ), x2 , B(hx1 i, hβ(hi )i )i
We have |s| = 3, and pos(s) = {1, 111, 2, 3, 311, 321}. Note that 31 is not a position, as
positions must point to terms, not s-terms. Further s|1 = α(A()), s|111 = A(), s|311 = x1 ,
s(2) = x2 , and s(3) = B.
An example of first-order substitution is s[δ1 , δ2 ] = α(A()) δ2 B(δ1 , β ). With s0 =
γ1 C(δ1 , δ2 ) γ2 , an example of second-order substitution is:
s0 JsK2 = γ1 α(A()) δ2 B(δ1 , β ) γ2
A s-term over a ranked alphabet ∆ = ∆(1) and its positions are illustrated in Figure 3.
3. Hybrid Trees
The purpose of this section is to unify existing notions of non-projective dependency
structures and discontinuous phrase structures, formalized using s-terms.
We fix a ranked alphabet Σ = Σ(1) and a subset Γ ⊆ Σ. A hybrid tree over (Γ, Σ ) is
∗
a pair h = (s, ≤s ), where s ∈ TΣ
and ≤s is a total order on posΓ (s). In words, a hybrid
tree combines hierarchical structure, in the form of a s-term over the full alphabet Σ,
with a linear structure, which can be seen as a string over Γ ⊆ Σ. This string will be
denoted by str(h). Formally, let posΓ (s) = {p1 , . . . , pn } with pi ≤s pi+1 (i ∈ [n − 1]). Then
471

Computational Linguistics

Volume 43, Number 3

zag
VP
(a)

V

Jan
ADV

hat

gearbeitet

schnell

hat

schnell

gearbeitet

(b)

helpen
Piet

lezen
Marie

(dat)

Jan

Piet Marie zag helpen lezen
(saw) (help) (read)

Figure 4
(a) Discontinuous phrase structure for German “[...] hat schnell gearbeitet” (“[...] has worked
quickly”), represented as hybrid tree. (b) Non-projective dependency structure for “Jan Piet Marie
zag helpen lezen,” represented as hybrid tree.

str(h) = s(p1 ) · · · s(pn ). In order to avoid the treatment of pathological cases we assume
that s 6= hi and posΓ (s) 6= ∅.
A hybrid tree (s, ≤s ) is a phrase structure if ≤s is a total order on the leaves of s.
The elements of Γ would typically represent lexical items, and the elements of Σ \ Γ
would typically represent syntactic categories. A hybrid tree (s, ≤s ) is a dependency
structure if Γ = Σ, whereby the linear structure of a hybrid tree involves all of its nodes,
which represent lexical items. Our dependency structures generalize totally ordered
trees (Kuhlmann and Niehren 2008) by considering s-terms instead of usual terms over
a ranked alphabet.
We say that a phrase structure (s, ≤s ) over (Γ, Σ ) is continuous if for each p ∈ pos(s)
the set posΓ (s|p ) is a complete span, that is, if the following condition holds: if p1 , p2 , p0
satisfy pp1 , p0 , pp2 ∈ posΓ (s) and pp1 ≤s p0 ≤s pp2 , then p0 = pp3 for some p3 . If the same
condition holds for a dependency structure (s, ≤s ), then we say that (s, ≤s ) is projective.
If the condition is not satisfied, then we call a phrase structure discontinuous and a
dependency structure non-projective.
Example 2
A simple example of a discontinuous phrase structure following Seifert and Fischer
(2004) is h = (s, ≤s ), where:
s = hVP(hV(hhat, gearbeiteti ), ADV(hschnelli )i )i
and ≤s is given by 11111 ≤s 11112 ≤s 11211. It is graphically represented in Figure 4a.
The bottom line indicates the word order in German, with adverb schnell [quickly]
separating the two verbs of the verb phrase. The dashed lines connect the leaves of the tree
structure to the total order. (Alternative analyses exist that do not require discontinuity;
we make no claim that the shown structure is the most linguistically adequate.)
Example 3
The phenomenon of cross-serial dependencies in Dutch (Bresnan et al. 1982) is illustrated
in Figure 4b, using a non-projective dependency structure.

472

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

S
a

S
a

b

S

b

a
a

a

a

b
b

b

b

Figure 5
Abstract representation of cross-serial dependencies in Dutch as discontinuous phrase structure.

Example 4
Figure 5 gives an abstract rendering of cross-serial dependencies in Dutch, this time in
terms of discontinuous phrase structure.
4. Basic Grammatical Formalisms
The concept of hybrid grammars is illustrated in Section 5, first on the basis of a coupling
of linear context-free rewriting systems and simple definite clause programs, and then
three more such couplings are introduced that further involve simple macro grammars
and simple context-free tree grammars. In the current section we discuss these basic
classes of grammars, starting with the simplest ones.
4.1 Macro Grammars
The definitions in this section are very close to those in Fischer (1968) with the difference
that the notational framework of s-terms is used for strings, as in Seki and Kato (2008).
A macro grammar (MG) is a tuple G = (N, S, Γ, P), where N is a ranked alphabet of
nonterminals, S ∈ N (0) is the start symbol, Γ = Γ(0) is a ranked alphabet of terminals
and Γ ∩ N = ∅, and P is a finite set of rules, each of the form:
A(x1,k ) → r

(1)

∗
where A ∈ N (k) and r ∈ TN
∪Γ (Xk ). A macro grammar in which each nonterminal has
rank 0 is a CFG.
p,ρ
We write ⇒G for the “derives” relation, using rule ρ = A(x1,k ) → r at position p in
p,ρ
∗
a s-term. Formally, we write s1 ⇒G s2 if s1 ∈ TN
∪Γ , s1 (p) = A and s2 = s1 JrKp . We write
p,ρ
s1 ⇒G s2 if s1 ⇒G s2 for some p and ρ, and ⇒∗G is the reflexive, transitive closure of ⇒G .
Derivation in i steps is denoted by ⇒iG . The (string) language induced by macro grammar
∗
G is [G] = {s ∈ TΓ
| hSi ⇒∗G s}.
In the sequel we will focus our attention on macro grammars with the property
that for each rule A(x1,k ) → r and each i ∈ [k], variable xi has exactly one occurrence in r.
In this article, such grammars will be called simple macro grammars (sMGs).

473

Computational Linguistics

Volume 43, Number 3

Example 5
A sMG and a derivation are the following, once more motivated by cross-serial dependencies:
S → A(ε )
A(x1 ) → a A(x1 a)
A(x1 ) → b A(x1 b)
A(x1 ) → x1

S ⇒G
⇒G
⇒G
⇒G

A(ε )
a A(a)
a b A(a b)
abab

All derived strings are of the form ww, where w is a string over {a, b}. In this and in
the following examples, bold letters (which may be lower-case or upper-case) represent
terminals and upper-case italic letters represent nonterminals.
4.2 Context-free Tree Grammars
The definitions in this section are a slight generalization of those in Rounds (1970) and
Engelfriet and Schmidt (1977, 1978), as here they involve s-terms. In Section 3 we already
argued that the extra power due to s-terms can be modeled using fixed symbols cons and
nil and is therefore not very significant in itself. The benefit of the generalization lies in
the combination with macro grammars, as discussed in Section 5.
A (generalized) context-free tree grammar (CFTG) is a tuple G = (N, S, Σ, P), where
Σ is a ranked alphabet with Σ = Σ(1) and N, S, and P are as for macro grammars except
that Γ is replaced by Σ in the specification of the rules.
p,ρ
The “derives” relation ⇒G and other relevant notation are defined as for macro
∗
grammars. Note that the language [G] = {s ∈ TΣ
| hSi ⇒∗G s} induced by a CFTG G is
not a string language but a tree language, or more precisely, its elements are sequences
of trees.
As for macro grammars, we will focus our attention on CFTGs with the property
that for each rule A(x1,k ) → r and each i ∈ [k], variable xi has exactly one occurrence in r.
In this article, such grammars will be called simple context-free tree grammars (sCFTGs).
Note that if N = N (0) , then a sCFTGs is a regular tree grammar (Brainerd 1969; Gécseg
and Steinby 1997). sCFTGs are a natural generalization of the widely used TAGs; see
Kepser and Rogers (2011), Maletti and Engelfriet (2012), and Gebhardt and Osterholzer
(2015).
Example 6
A sCFTG and a derivation are provided here. This example models a simple recursive
structure, where a could stand for a noun, b for a verb, and c for an adverb that modifies
exactly one of the verbs.
S → A(c)
A(x1 ) → S(a A(x1 ) b)
A(x1 ) → S(a A(ε ) b x1 )
A(x1 ) → S(a b x1 )

S ⇒G
⇒G
⇒G
⇒G

A(c)
S(a A(c) b)
S(a S(a A(ε ) b c) b)
S(a S(a S(a b) b c) b)

4.3 Linear Context-free Rewriting Systems
In Vijay-Shanker, Weir, and Joshi (1987), the semantics of LCFRS is introduced by
distinguishing two phases. In the first phase, a tree over function symbols is generated by

474

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

a regular tree grammar. In the second phrase, the function symbols are interpreted, each
composing a sequence of tuples of strings into another tuple of strings. This formalism
is equivalent to the multiple CFGs of Seki et al. (1991). We choose a notation similar
to that of the formalisms discussed before, which will also enable us to couple these
string-generating grammars to tree-generating grammars, as will be discussed later.
A linear context-free rewriting system (LCFRS) is a tuple G = (N, S, Γ, P), where N
is a ranked alphabet of nonterminals, S ∈ N (1) is the start symbol, Γ = Γ(0) is a ranked
alphabet of terminals and Γ ∩ N = ∅, and P is a finite set of rules, each of the form:
A0 (s1,k0 ) → hA1 (x1,m1 ), A2 (xm1 +1,m2 ), . . . , An (xmn−1 +1,mn )i

(2)

P
where n ∈ N, Ai ∈ N (ki ) for each i ∈ [n]0 , and mi = j:1≤j≤i kj for each i ∈ [n], and
∗
sj ∈ TΓ
(Xmn ) for each j ∈ [k0 ]. In words, the right-hand side is a s-term consisting of
nonterminals Ai (i ∈ [n]), with ki distinct variables as arguments; there are mn variables
altogether, which is the sum of the ranks of all Ai (i ∈ [n]). The left-hand side is
an occurrence of A0 with each argument being a string of variables and terminals.
Furthermore, we demand that each xj ( j ∈ [mn ]) occurs exactly once on the left-hand side.
The rank of a nonterminal is called its fanout and the largest rank of any nonterminal is
called the fanout of the grammar.
Given a rule ρ of the form of Equation (2), a rule instance of ρ is obtained by choosing
∗
some ri ∈ TΓ
for each variable xi (i ∈ [mn ]), and replacing the two occurrences of xi in
the rule by this ri . Much as in the preceding sections, ⇒ρ
G is a binary relation on s-terms,
with:
s1 · hti · s2 ⇒ρ
G s1 · r · s2

S
if t → r is a rule instance of ρ. We write ⇒G for ρ∈P ⇒ρ
G . The (string) language induced
∗
by LCFRS G is [G] = {s ∈ TΓ
| hS(s)i ⇒∗G hi}. If hS(s)i ⇒∗G hi, then there are i ∈ N and
ρ1 , . . . , ρi such that hS(s)i ⇒ρG1 · · · ⇒ρGi hi. We call ρ1 · · · ρi a derivation of G.
A derivation can be represented by a derivation tree d (cf. Figure 6), which is
obtained by glueing together the rules as they are used in the derivation. The backbone
of d is a usual derivation tree of the CFG underlying the LCFRS (nonterminals and
solid lines). Each argument of a nonterminal is represented as a box to the right of the
nonterminal, and dashed arrows indicate dependencies of values. An xi above a box

S x1 x3 x2 x4
S(a a c b b d)
⇒G A(a a, b b) B(c, d)
⇒G A(a, b)
B(c, d)
⇒G A(ε, ε )
B(c, d)
⇒G
B(c, d)
⇒G
B(ε, ε )
⇒G
ε

x1
x2
A a x1 b x2

x3
x4
B c x1 d x2

x1
x2
A a x1 b x2

B

A

x1
ε

x1
ε

x2
ε

x2
ε

Figure 6
Derivation and derivation tree of the LCFRS in Example 7.

475

Computational Linguistics

Volume 43, Number 3

specifies an argument of a nonterminal on the right-hand side of a rule, whereas the
content of a box is an argument of the nonterminal on the left-hand side of a rule. The
boxes taken as vertices and the dashed arrows taken as edges constitute a dependency
graph. It can be evaluated by first sorting its vertices topologically and, according to
this sorting, substituting in an obvious manner the relevant s-terms into each other.
The final s-term that is evaluated in this way is an element of the language [G]. This
s-term, denoted by φ(d), is called the evaluation of d. The notion of dependency graph
originates from attribute grammars (Knuth 1968; Paakki 1995); it should not be confused
with the linguistic concept of dependency.
Note that if the rules in a derivation are given, then the choice of ri for each variable
xi in each rule instance is uniquely determined. For a given string s, the set of all LCFRS
derivations (in compact tabular form) can be obtained in polynomial time in the length
of s (Seki et al. 1991). See also Kallmeyer and Maier (2010, 2013) for the extension with
probabilities.
Example 7
An example of a LCFRS G is the following:
S(x1 x3 x2 x4 ) → A(x1 , x2 ) B(x3 , x4 )

A(ax1 , bx2 ) → A(x1 , x2 )
B(cx1 , dx2 ) → B(x1 , x2 )

A(ε, ε ) → ε
B(ε, ε ) → ε

A derivation of G and the corresponding derivation tree d is depicted in Figure 6; its
evaluation is the s-term φ(d) = a a c b b d.
All strings derived by G have the interlaced structure am cn bm dn with m, n ∈ N, where
the i-th occurrence of a corresponds to the i-th occurrence of b and the i-th occurrence
of c corresponds to the i-th occurrence of d. This resembles cross-serial dependencies in
Swiss German (Shieber 1985) in an abstract way; a and c represent noun phrases with
different case markers (dative or accusative) and b and d are verbs that take different
arguments (dative or accusative noun phrases).
There is a subclass of LCFRS called well-nested LCFRS. Its time complexity of
parsing is lower than that of general LCFRS (Gómez-Rodríguez, Kuhlmann, and Satta
2010), and the class of languages it induces is strictly included in the class of languages
induced by general LCFRSs (Kanazawa and Salvati 2010). One can see sMGs as syntactic
variants of well-nested LCFRSs (cf. footnote 3 of Kanazawa 2009), the former being
more convenient for our purposes of constructing hybrid grammars, when the string
component is to be explicitly restricted to have the power of sMG / well-nested LCFRS.
The class of languages they induce also equals the class of string languages induced
by sCFTGs.
4.4 Definite Clause Programs
In this section we describe a particular kind of definite clause program. Our definition is
inspired by Deransart and Małuszynski (1985), who investigated the relation between
logic programs and attribute grammars, together with the “syntactic single use requirement” from Giegerich (1988). The values produced are s-terms. The induced class of
s-term languages is strictly larger than that of sCFTGs (cf. Appendix B).
As discussed subsequently, the class of string languages that results if we take the
yields of those s-terms equals the class of string languages induced by LCFRSs. Thereby,

476

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

our class of definite clause programs relates to LCFRSs much as the class of sCFTGs
relates to sMGs.
A simple definite clause program (sDCP) is a tuple G = (N, S, Σ, P), where N is a
ranked alphabet of nonterminals and Σ = Σ(1) is a ranked alphabet of terminals (as for
CFTGs).2 Moreover, each nonterminal A ∈ N has a number of arguments, each of which
is either an inherited argument or a synthesized argument. The number of inherited
arguments is the i-rank and the number of synthesized arguments is the s-rank of A;
we let rkN (A) = i-rk(A) + s-rk(A) denote the rank of A. The start symbol S has only one
argument, which is synthesized—that is, rkN (S) = s-rk(S) = 1 and i-rk(S) = 0.
A rule is of the form:
(0)

(0)

(1)

(1)

(n)

(n)

A0 (x1,k0 , s1,k0 ) → hA1 (s1,k0 , x1,k1 ), . . . , An (s1,k0 , x1,kn )i
0

1

n

(3)

where n ∈ N, k0 = i-rk(A0 ) and k00 = s-rk(A0 ), ki0 = i-rk(Ai ) and ki = s-rk(Ai ), for i ∈ [n].
P
(i)
The set of variables occurring in the lists x1,ki (i ∈ [n]0 ) equals Xm , where m = i∈[n]0 ki .
In other words, every variable from Xm occurs exactly once in all these lists together. This
(i)
∗
is where values “enter” the rule. Further, the s-terms in s1,k0 (i ∈ [n]0 ) are in TΣ
(Xm ) and
i
together contain each variable in Xm exactly once (syntactic single use requirement). This
is where values are combined and “exit” the rule.
The “derives” relation ⇒G and other relevant notation are defined as for LCFRSs.
∗
Thus, in particular, the language induced by sDCP G is [G] = {s ∈ TΣ
| hS(s)i ⇒∗G hi},
whose elements are now sequences of trees.
In the same way as for LCFRS we can represent a derivation of a sDCP G as derivation
tree d. A box in its dependency graph is placed to the left of a nonterminal occurrence if
it represents an inherited argument and to the right otherwise. As before, φ(d) denotes
the evaluation of d, which is now a s-term over Σ.
Example 8
A sDCP and a derivation are the following, where the first argument of B is inherited
and all other arguments are synthesized:
S(x2 ) → A(x1 ) B(x1 , x2 )
A(a A(x1 ) b) → A(x1 )
A(ε ) → ε
B(x1 , c B(x2 ) d) → B(x1 , x2 )
B(x1 , x1 ) → ε

S(c
 B(c B(a A()
 b) d) d)

⇒ A a A() b B a A() b, c B(c B(a A() b) d) d


⇒2 A(ε ) B a A() b, c B(a A() b) d


⇒2 B a A() b, a A() b

⇒ ε

Figure 7 shows the derivation tree d, whose evaluation is the s-term φ(d) =
c B(c B(a A() b) d) d that is derived by the sDCP of this Example.
If a sDCP is such that the dependency graph for any derivation contains no cycles,
then we say the sDCP contains no cycles. In this case, if the rules in a derivation are given,
then the choice of ri for each variable xi in each rule instance is uniquely determined, and
can be computed in linear time in the size of the derivation. The existence of cycles is

2 The term “simple” will here be used for definite clause programs to have analogous meaning to the term
for MGs and CFTGs. This is more restrictive than the term with the same name in Deransart and
Małuszynski (1985).

477

Computational Linguistics

S
x1
a
A(x
A
1) b

A

x1
ε

Volume 43, Number 3

x2

x1
x1

B

x2
c B(x2 ) d

x2
B c B(x2 ) d

x1
x1
x1
x1

B

x2
x1

Figure 7
The derivation tree corresponding to the derivation in Example 8.

decidable, as we know from the literature on attribute grammars (Knuth 1968). There
are sufficient conditions for absence of cycles, such as the grammar being L-attributed
(Bochmann 1976; Deransart, Jourdan, and Lorho 1988). In this article, we will assume
that sDCPs contain no cycles. A one-pass computation model can be formalized as a
bottom–up tree-generating tree-to-hypergraph transducer (Engelfriet and Vogler 1998).
One may alternatively evaluate sDCP arguments using the more general mechanism of
unification, as it exists for example in HPSG (Pollard and Sag 1994).
If the sDCP is single-synthesized—that is, each nonterminal has exactly one synthesized argument (and any number of inherited arguments)—then there is an equivalent
sCFTG. The converse also holds. For proofs, see Appendix A.
Theorem 1
Single-synthesized sDCPs have the same s-term generating power as sCFTGs.
Example 9
The sDCP from Example 8 is transformed into the following sCFTG:
S0 → B0 (A0 )
B (x1 ) → c B(B0 (x1 )) d
B0 (x1 ) → x1
0

A0 → a A(A0 ) b
A0 → ε

A sDCP induces a language of s-terms. By flattening the structure of those s-terms,
one obtains a string language. More precisely, we define the flattening function “pre”
∗
∗
from TΣ (X) ∪ TΣ
(X) to TΣ
(X), which returns the sequence of node labels in a pre-order
∗
tree traversal. (Alternatively, one could define a function “yield” from TΣ (X) ∪ TΣ
(X)
∗
to TΓ (X), where Γ is a subset of Σ, which erases symbols in Σ \ Γ. The erased symbols
would typically be linguistic categories as opposed to lexical elements. This does not
affect the validity of what follows, however.) We define recursively:
pre(ht1 , . . . , tn i ) = pre(t1 ) · . . . · pre(tn )
pre(δ(s)) = hδ(hi )i · pre(s)
pre(x) = hxi
On the basis of the flattening function, Appendix C proves the following result.

478

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

Theorem 2
sDCP have the same string generating power as LCFRS.
5. Hybrid Grammars
A hybrid grammar consists of a string grammar and a tree grammar. Intuitively, the string
grammar is used for parsing a given string w, and the tree grammar simultaneously
generates a hybrid tree h with str(h) = w. To synchronize these two processes, we
couple derivations in the grammars in a way similar to how this is commonly done
for synchronous grammars—namely, by indexed symbols. However, we apply the
mechanism not only to derivational nonterminals but also to terminals.
Let Ω be a ranked alphabet. We define the ranked set I(Ω ) = {ω u | ω ∈ Ω, u ∈ N+ },
with rkI (Ω) (ω u ) = rkΩ (ω ). Let ∆ be another ranked alphabet (Ω ∩ ∆ = ∅) and Y ⊆ X.
∗
∗
We let IΩ
,∆ (Y) be the set of all s-terms s ∈ TI (Ω )∪∆ (Y) in which each index u occurs at
most once.
For a s-term s, let ind(s) be the set of all indices occurring in s. The deindexing
∗
∗
function D removes all indices from a s-term s ∈ IΩ
,∆ (Y) to obtain D(s) ∈ TΩ∪∆ (Y).
The set IΩ,∆ (Y) ⊆ TI (Ω)∪∆ (Y) of terms with indexed symbols is defined much as above.
∗
∗
We let IΩ
,∆ = IΩ,∆ (∅ ) and IΩ,∆ = IΩ,∆ (∅ ).
5.1 LCFRS/sDCP Hybrid Grammars
We first couple a LCFRS and a sDCP in order to describe a set of hybrid trees.
A LCFRS/sDCP hybrid grammar (over Γ and Σ) is a tuple G = (N, S, (Γ, Σ ), P),
subject to the following restrictions. The objects Γ and Σ are ranked alphabets with
Γ = Γ(0) and Σ = Σ(1) . As mere sets of symbols, we demand Γ ⊆ Σ. Let ∆ be the ranked
alphabet Σ \ Γ, with rk∆ (δ ) = rkΣ (δ ) = 1 for δ ∈ ∆. The set P is a finite set of hybrid
rules, each of the form:
(1)

(2)

[A(s1,k ) → r1 , A(s1,m ) → r2 ]

(4)

(1)

where D(A(s1,k )) → D(r1 ) satisfies the syntactic constraints of an individual LCFRS rule
(2)

and D(A(s1,m )) → D(r2 ) satisfies the syntactic constraints of a sDCP rule. The added
(1)

(2)

indices occur at nonterminals in r1 and r2 and at terminals from Γ in s1,k and in s1,m and
r2 . We require that each index in a hybrid rule either couples a pair of identical terminals
(1)
or couples a pair of identical nonterminals. Let P1 be the set of all D(A(s1,k )) → D(r1 ),
(1)

where A(s1,k ) → r1 occurs as the first component of a hybrid rule as in Equation (4). The
set P2 is similarly defined, taking the second components. We now further require that
(N, S, Γ, P1 ) is a LCFRS and (N, S, Σ, P2 ) is a sDCP. We refer to these two grammars as
the first and second components, respectively, of G.
ρ
In order to define the “derives” relation ⇒u,
G , for some index u and some rule ρ
of the form of Equation (4), we need the additional notions of nonterminal reindexing
and of terminal reindexing. The nonterminal reindexing is an injective function fU that
replaces each index at a nonterminal occurrence of the rule by one that does not clash
with the indices in an existing set U ⊆ N+ . We may, for example, define fU such that it
maps each v ∈ N+ to the smallest v0 ∈ N+ such that v0 ∈
/ U ∪ {fU (1), . . . , fU (v − 1)}. We

479

Computational Linguistics

Volume 43, Number 3

extend fU to apply to terms, s-terms, and rules in a natural way, to replace indices by
other indices, but leaving all other symbols unaffected. A terminal reindexing g maps
indices at occurrences of terminals in the rule to the indices of corresponding occurrences
of terminals in the sentential form; we extend g to terms, s-terms, and rules in the same
way as for fU . The definition of fU is fixed while an appropriate g needs to be chosen for
each derivation step.
We can now formally define:
(1)

(2)

ρ
[s1 · hA (s0 1,k )i · s01 , s2 · hA (s0 1,k )i · s02 ] ⇒u,
[s1 · r01 · s01 , s2 · r02 · s02 ]
G
u

u

(1)

for every s1 , s01 ∈ IN∗ ∪Γ,∅ , sequence s0 1,k of s-terms in IΓ∗,∅ , and s2 , s02 ∈ IN∗ ∪Γ,∆ and
(2)

sequence s0 1,k of s-terms in IΓ∗,∆ , if:

r

(1)
(2)
ρ ∈ P is [A(s1,k
) → r1 , A(s1,k ) → r2 ],

r

U = ind(s1 · hA u (s0 1,k )i · s01 ) \ {u} = ind(s2 · hA u (s0 1,k )i · s02 ) \ {u},

r

there is a terminal reindexing g such that g(s1,k ) = s0 1,k (and hence

(1)

(2)

(1)

(1)

(2)

(2)

g(s1,k ) = s0 1,k ),

r

(1)

(1)

A(s0 1,k ) → r01 is obtained from g( fU (A(s1,k ) → r1 )) by consistently
(2)

substituting occurrences of variables by s-terms in IΓ∗,∅ , and A(s0 1,k ) → r02 is
(2)

obtained from g( fU (A(s1,k ) → r2 )) by consistently substituting occurrences
of variables by s-terms in IΓ∗,∆ .
Example 10
Let us consider the rule:

ρ : [A(x1 a 3 x2 ) → B 1 (x1 ) C 2 (x2 ), A(d(a 3 x1 x2 )) → B 1 (x1 ) C 2 (x2 )]
of some LCFRS/sDCP hybrid grammar and the sentential form:
2

3

1

4

5

6

2

3

1

5

4

6

[D (a ) A (b a c ), D (a ) A (d(a b c ))]
We apply ρ to the underlined subterms, that is, u = 1. We have:
2

3

1

4

5

6

U = ind(D (a ) A (b a c )) \ {1} = {2, 3, 4, 5, 6}
We define the nonterminal reindexing such that fU (1) = 1 and fU (2) = 7. As terminal
reindexing we use g such that g(3) = 5. Thus we obtain the reindexed rule:
5

1

7

5

1

7

g( fU (ρ )) = [A(x1 a x2 ) → B (x1 ) C (x2 ), A(d(a x1 x2 )) → B (x1 ) C (x2 )]
480

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

By using the substitutions x1 7→ b 4 and x2 7→ c 6 for both components we obtain the
derivation step:
2

3

1

4

5

6

2

3

1

6

2

3

1

5

4

6

[D (a ) A (b a c ), D (a ) A (d(a b c ))]
ρ
⇒1,
G

2

3

1

4

7

4

7

6

[D (a ) B (b ) C (c ), D (a ) B (b ) C (c )]

We write ⇒G for

S

u∈N+,ρ∈P

u,ρ
⇒G
. The hybrid language induced by G is:

[G] = {[s1 , s2 ] ∈ IΓ∗,∅ × IΓ∗,∆ | [hS (s1 )i, hS (s2 )i] ⇒∗G [hi, hi]}
1

1

(5)

Note that apart from the indices, the first component of a pair [s1 , s2 ] ∈ [G] consists of
a string of terminals from Γ and the second is a s-term built up of terminals in Γ ∪ ∆.
Moreover, every occurrence of γ ∈ Γ in s1 corresponds to exactly one in s2 and vice versa,
because of the common indices.
From a pair [s1 , s2 ] ∈ [G], we can construct the hybrid tree (s, ≤s ) over (Γ, Σ ) by
letting s = D(s2 ) and, for each combination of positions p1 , p01 , p2 , p02 such that s1 (p1 ) =
s2 (p2 ) ∈ I(Γ ) and s1 (p01 ) = s2 (p02 ) ∈ I(Γ ), we set p2 ≤s p02 if and only if p1 ≤` p01 . (The
lexicographical ordering ≤` on positions here simplifies to the linear ordering of integers,
as positions in strings always have length 1.) In words, occurrences of terminals in s
obtain a total order in accordance with the order in which corresponding terminals
occur in s1 . The set of all such (s, ≤s ) will be denoted by L(G).
Example 11
Abbreviating each German word by its first letter, the hybrid tree in Figure 4a is
obtained by the following LCFRS/sDCP hybrid grammar G. (All arguments in the
second component are synthesized.)

ρ1 : [VP(x1 x2 x3 ) → V 1 (x1 , x3 ) ADV 2 (x2 ), VP(VP(x1 x2 )) → V 1 (x1 ) ADV 2 (x2 )]
1

1

ρ2 : [V(h , g 2 ) → ε, V(V(h g 2 )) → ε]
ρ3 : [ADV(s 1 ) → ε, ADV(ADV(s 1 )) → ε]
We derive:
1

2

3

4

1

2

4

3

[VP (h s g ), VP (VP(V(h g ) ADV(s )))]
1
5
1
5
4
3
4
3
ρ1
⇒1,
[V (h , g ) ADV (s ), V (V(h g )) ADV (ADV(s ))]
G
2

2

5
5
3
3
ρ2
⇒1,
[ADV (s ), ADV (ADV(s ))]
G

ρ3
⇒5,
[ε, ε]
G

where we have used the following reindexing functions:
application of ...

nonterminal reindexing

terminal reindexing

ρ1
f{2,3,4} (2) = 5
g identity
ρ2
f{2,3,4,5} identity
g(1) = 2 and g(2) = 4
ρ3
f{3} identity
g(1) = 3
and fU (i) = i and g( j) = j if not specified otherwise.
481

Computational Linguistics

Volume 43, Number 3

Note that in the LCFRS that is the first component, nonterminal V has fanout 2, and
the LCFRS thereby has fanout 2. The tree produced by the second component is a parse
tree in the traditional sense—that is, it specifies exactly how the first component analyzes
the input string. Each LCFRS can in fact be extended to become a canonical LCFRS/sDCP
hybrid of this kind, in which there is no freedom in the coupling of the string grammar
and the tree grammar. Traditional frameworks for LCFRS parsing can be reinterpreted as
using such hybrid grammars.
To give a first illustration of the additional freedom offered by LCFRS/sDCP hybrid
grammars, consider the following alternative, where the first and second components
have a different structure. It derives the same hybrid tree, but now with all nonterminals
in the first component having fanout 1, by which we obtain a syntactic variant of a
context-free grammar. This, however, requires the second component to have a less
straightforward form:
1

1

[VP(x1 ) → V (x1 ), VP(VP(x1 )) → V (x1 )]
1

1

3

2

3

2

[V(h x1 g ) → ADV (x1 ), V(V(h g ) x1 ) → ADV (x1 )]
1

1

[ADV(s ) → ε, ADV(ADV(s )) → ε]
A derivation of a LCFRS/sDCP hybrid grammar G can be represented by a
derivation tree (cf. Figure 8). It combines a derivation tree of the first component
of G and a derivation tree of its second component, letting them share the common
parts. We make a graphical distinction between arguments of the first component
(rectangles) and those of the second component (ovals). Implicit in a derivation tree
is the reindexing of terminal indices. The evaluation φ1 of the derivation tree d in
2
Figure 8 yields the indexed string φ1 (d) = h s 3 g 4 and the evaluation φ2 of d yields the
2
4
3
tree φ2 (d) = VP(V(h g ) ADV(s )).
Example 12
The hybrid tree in Figure 4b can be obtained by the following LCFRS/sDCP hybrid
grammar. In the second component, T (for transitive verb) has two inherited arguments,
for the subject and the object, whereas I (intransitive verb) has one inherited argument,

VP

ρ1 : VP x1 x2 x3

x1

x3

ρ2 : V h 2

g4

x1
V
4
h g
2

x1 x2

x2

ρ3 : ADV s 3

x2
ADV
s3

Figure 8
The derivation tree corresponding to the derivation shown in Example 11.

482

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

for the subject. (To keep the example simple, we conflate different verb forms, so that the
grammar overgenerates.)
1

1

[S(x1 x2 ) → S2 (x1 , x2 ) , S(x1 ) → S2 (x1 )]
1

2

1

3

2

3

[S2 (x1 x3 , x2 x4 ) → N (x1 )T (x2 )S2 (x3 , x4 ) , S2 (x3 ) → N (x1 )T (x1 , x2 , x3 )S2 (x2 )]
1

2

1

2

[S2 (x1 , x2 ) → N (x1 )I (x2 ) , S2 (x2 ) → N (x1 )I (x1 , x2 )]
1

1

[T(zag ) → ε , T(x1 , x2 , zag (x1 x2 )) → ε]
1

1

[T(helpen ) → ε , T(x1 , x2 , helpen (x1 x2 )) → ε]
1

1

[I(lezen ) → ε , I(x1 , lezen (x1 )) → ε]
1

1

[N(Jan ) → ε , N(Jan ) → ε], etc.
We derive (abbreviating each Dutch word by its first letter):
1

2

3

4

6

5

7

1

5

6

2

7

3

4

[S (J P M z h l ) , S (z (J h (P l (M ))))]
6

7

6

7

⇒ [S21 (J 2 P 3 M 4 , z 5 h l ) , S21 (z 5 (J 2 h (P 3 l (M 4 ))))]
6

7

⇒ [N 8 (J 2 )T 9 (z 5 )S21 (P 3 M 4 , h l ) ,
8

2

9

6

2

7

3

4

5

6

2

3

7

4

1

6

3

7

4

N (J )T (J , h (P l (M )), z (J h (P l (M ))))S2 (h (P l (M )))]

⇒2 [S21 (P 3 M 4 , h l ) , S21 (h (P 3 l (M 4 )))]
6

7

7

6

6

7

⇒ [N 8 (P 3 )T 9 (h )S21 (M 4 , l ) ,
8

3

9

3

7

4

6

3

7

4

1

7

4

N (P )T (P , l (M ), h (P l (M )))S2 (l (M ))]

⇒2 [S21 (M 4 , l ) , S21 (l (M 4 ))]
7

7

⇒ [N 8 (M 4 )I 9 (l ) , N 8 (M 4 )I 9 (M 4 , l (M 4 ))] ⇒2 ε
7

7

5.2 Other Classes of Hybrid Grammars
In order to illustrate the generality of our framework, we will sketch three more classes
of hybrid grammars. In these three classes, the first component or the second component,
or both, are less powerful than in the case of the LCFRS/sDCP hybrid grammars defined
previously, and thereby the resulting hybrid grammars are less powerful, in the light of
the observation that sMGs are syntactic variants of well-nested LCFRSs and sCFTGs are
syntactic variants of sDCPs with s-rank restricted to 1. Noteworthy are the differences
between the four classes of hybrid grammars in the formal definition of their derivations.
A sMG/sCFTG hybrid grammar (over Γ and Σ) is a tuple G = (N, S, (Γ, Σ ), P), where
Γ and Σ are as in the case of LCFRS/sDCP hybrid grammars. The hybrid rules in P are
now of the form:
[A(x1,k ) → r1 , A(x1,k ) → r2 ]

(6)

where A(x1,k ) → D(r1 ) is a sMG rule and A(x1,k ) → D(r2 ) is a sCFTG rule.
ρ
In the definition of the “derives” relation ⇒u,
G we have to use a reindexing function.
Because terminals are produced by a rule application (instead of being consumed as in
the LCFRS/sDCP case), there is no need for a terminal reindexing that matches indices

483

Computational Linguistics

Volume 43, Number 3

of terminal occurrences of the applied rule with those of the sentential form. Instead,
terminal indices occurring in the rule have to be reindexed away from the sentential
form in the same way as for nonterminal indices. Thus we use one reindexing function
fU that applies to nonterminal indices and terminal indices.
ρ 0 0
0
∗
0
∗
We define [s1 , s2 ] ⇒u,
G [s1 , s2 ] for every s1 , s1 ∈ IN∪Γ,∅ and s2 , s2 ∈ IN∪Γ,∆ if and
only if:

r
r
r
r

there are positions p1 and p2 such that s1 (p1 ) = A u and s2 (p2 ) = A u ,

ρ ∈ P is [A(x1,k ) → r1 , A(x1,k ) → r2 ],
U = ind(s1 ) \ {u} = ind(s2 ) \ {u},
s0i = si JfU (ri )Kpi for i = 1, 2.

We write ⇒G for

S

u∈N+,ρ∈P

ρ
⇒u,
G and define the hybrid language induced by G as:

[G] = {[s1 , s2 ] ∈ IΓ∗,∅ × IΓ∗,∆ | [hS i, hS i] ⇒∗G [s1 , s2 ]}
1

1

(7)

As before, this defines a set L(G) of hybrid trees. Note the structural difference between
Equations (5) and (7).
Example 13
The hybrid tree in Figure 4a is obtained by the following sMG/sCFTG hybrid grammar:
1

2

1

2

[VP → V (ADV ) , VP → VP(V ADV )]
1

1

[V(x1 ) → h x1 g

2

, V → V(h g )]

2

[ADV → s

1

, ADV → ADV(s )]

1

We derive:
1

1

1

2

1

2

[VP , VP ] ⇒ [V (ADV ), VP(V ADV )]
1

1

⇒ [h ADV 2 g 3 , VP(V(h g 3 ) ADV 2 )]
1

1

⇒ [h s 2 g 3 , VP(V(h g 3 ) ADV(s 2 ))]
As in Example 11, there is an alternative hybrid grammar in which all nonterminals in
the first component have rank 0, which is thereby context-free. This is at the expense of a
more complicated second component.
Example 14
Hybrid trees for cross-serial dependencies as in Figure 5 can be obtained through the
following sMG/sCFTG hybrid grammar, with start symbol A:
1

1

[A → S (ε ) , A → S ]
[S(x1 ) → a

1

3

2

1

3

2

S (x1 b ) , S → S(a S b )]
[S(x1 ) → x1 , S → ε]

One can derive, for instance:
[A , A ] ⇒∗ [a a b b , S(a
1

484

1

1

2

3

5

1

2

5

3

S(a b ) b )]

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

Analogously to LCFRS/sDCP and sMG/sCFTG hybrid grammars, one can
define LCFRS/sCFTG hybrid grammars and sMG/sDCP hybrid grammars, with
suitable definitions of ⇒G obtained straightforwardly by combining elements
from the earlier definitions. The hybrid language induced by LCFRS/sCFTG hybrid
grammar G is:
[G] = {[s1 , s2 ] ∈ I ∗Γ,∅ × I ∗Γ,∆ | [hS (s1 )i, hS i] ⇒∗G [hi, s2 ]}
1

1

and the hybrid language induced by sMG/sDCP hybrid grammar G is:
[G] = {[s1 , s2 ] ∈ I ∗Γ,∅ × I ∗Γ,∆ | [hS i, hS (s2 )i] ⇒∗G [s1 , hi]}
1

1

Example 15
The hybrid tree in Figure 4a is obtained by the LCFRS/sCFTG hybrid grammar:
2

1

1

2

[VP(x1 x2 x3 ) → V (x1 , x3 ) ADV (x2 ) , VP → VP(V ADV )]
1

1

2

2

[V(h , g ) → ε , V → V(h g )]
1

1

[ADV(s ) → ε , ADV → ADV(s )]
The derivation of the hybrid tree in Figure 4a is:
2

1

3

1

4

[VP (h s g ), VP ]
2

⇒ [V 1 (h , g 4 ) ADV 5 (s 3 ), VP(V 1 ADV 5 )]
2

⇒ [ADV 5 (s 3 ), VP(V(h , g 4 ) ADV 5 )]
2

⇒ [ε, VP(V(h , g 4 ) ADV(s 3 ))]
A sMG/sDCP hybrid grammar that achieves the same is:
2

1

1

2

[VP → V (ADV ) , VP(VP(x1 x2 )) → V (x1 ) ADV (x2 )]
1

1

[V(x1 ) → h x1 g

2

, V(V(h g )) → ε]

2

[ADV → s

1

, ADV(ADV(s )) → ε]

1

We can derive:
1

2

1

4

3

[VP , VP (VP(V(h , g ) ADV(s )))]
2

⇒ [V 1 (ADV 5 ), V 1 (V(h , g 4 )) ADV 5 (ADV(s 3 ))]
⇒ [h

2

ADV

5

4

5

3

g , ADV (ADV(s ))]

2

⇒ [h s 3 g 4 , ε]
5.3 Probabilistic LCFRS/sDCP Hybrid Grammars and Parsing
In the usual way, we can extend LCFRS/sDCP hybrid grammars to become probabilistic
LCFRS/sDCP hybrid grammars. For this we can assign a probability to each hybrid rule,

485

Computational Linguistics

Volume 43, Number 3

Algorithm 1 Parsing a string with probabilistic LCFRS/sDCP hybrid grammars
probabilistic LCFRS/sDCP hybrid grammar G over Γ and Σ
w = α1 · · · αn ∈ Γ∗
Output: hybrid tree h with str(h) = w and with most probable derivation

Input:

1:
2:
3:

4:
5:
6:

extract the first component of G; resulting in a probabilistic LCFRS G0
parse w according to G0 with any standard LCFRS parser; resulting in a most likely
derivation tree d
enrich the dependency graph of d by the arguments which correspond to the
second components of the applied LCFRS/sDCP rules; resulting in the intermediate
structure dˆ
choose a terminal indexing of w; resulting in s1 ∈ IΓ∗,∅
traverse dˆ and reindex terminal indices to match those in s1 ; resulting in derivation
tree d0
return hybrid tree h corresponding to [s1 , φ2 (d0 )]

under the constraint of a properness condition. More precisely, for each nonterminal A
the probabilities of all hybrid rules with A in their left-hand sides sum up to 1. In this
way a probabilistic LCFRS/sDCP hybrid grammar induces a distribution over hybrid
trees. Thus it can be considered as a generative model. See also Nivre (2010) for a general
survey of probabilistic parsing.
Algorithm 1 shows a parsing pipeline which takes as input a probabilistic
LCFRS/sDCP hybrid grammar G and a sentence w ∈ Γ∗ . As output it computes the
hybrid tree h ∈ L(G) that is derived by the most likely derivation whose first component
derives w. In line 1 the first component of G is extracted. Because we later will restore the
second component, we assume that a tag is attached to each LCFRS rule that uniquely
identifies the original LCFRS/sDCP rule. This also means that two otherwise identical
LCFRS rules are treated as distinct if they were taken from two different LCFRS/sDCP
rules. In line 2 the string w is parsed. For this any standard LCFRS parser can be used.
Such parsers, for instance those by Seki et al. (1991) and Kallmeyer (2010), typically
run in polynomial time. The technical details of the chosen LCFRS parser (like the used
form of items or the form of iteration over rules) are irrelevant, as for our framework
only the functionality of the parsing component matters. The parsing algorithm builds
a succinct representation of all derivations of w. In a second, linear-time phase the
most likely derivation tree d for w is extracted. In line 3 the dependency graph of d is
enriched by the inherited and synthesized arguments that correspond to the second
components of the rules occurring in d; here, the identity of the original LCFRS/sDCP
ˆ This is not yet a derivation
rule is needed. This results in an intermediate structure d.
tree of G, as the terminals still need to be assigned unique indices. This is done first by
an indexing of the terminals from w in an arbitrary manner, and then by traversing the
derivation to associate these indices with the appropriate terminal occurrences in the
derivation, leading to a derivation tree d0 of the LCFRS/sDCP hybrid grammar G. Note
that φ1 (d0 ) = s1 . Finally, in line 6 the derivation tree d0 is evaluated by φ2 yielding a tree
in IΓ∗,∆ .
We illustrate Algorithm 1 by means of the (non-probabilistic) LCFRS/sDCP hybrid
ˆ d0 , and
grammar G from Example 11 and the sentence w = h s g. Figure 9 shows d, d,

486

Gebhardt, Nederhof, and Vogler

d:

ρ1 : VP x1 x2 x3

x1 x3
ρ2 : V h g

x2
ρ3 : ADV s

Hybrid Grammars

d:ˆ

enrich

VP

ρ1 : VP x1 x2 x3

dependency
graph

x1

x3

ρ2 : V h 1

g2

x1 x2

x1
V
2
h g
1

x2

ρ3 : ADV s 1

x2
ADV
s1

standard
LCFRS parser
for G0
2

s1 = h s 3 g 4
d0:
w=hsg

VP

ρ1 : VP x1 x2 x3

x1

x3

ρ2 : V h 2

g4

x1
V
4
h g
2

x1 x2

x2

ρ3 : ADV s 3

x2
ADV
s3

Figure 9
Algorithm 1 applied to the LCFRS/sDCP hybrid grammar G from Example 11 and the sentence
w = h s g.

s1 ; as part of d0 we obtain φ2 (d0 ) = VP(V(h g 4 ) ADV(s 3 )). The LCFRS grammar G0
resulting from the extraction in line 1 is:
2

ρ1 : VP(x1 x2 x3 ) → V(x1 , x3 ) ADV(x2 )

ρ2 : V(h, g) → ε

ρ3 : ADV(s) → ε

6. Grammar Induction
For most practical applications, hybrid grammars would not be written by hand, but
would be automatically extracted from finite corpora of hybrid trees, over which they
should generalize. To be precise, the task is to construct a hybrid grammar G out of a
corpus c such that c ⊆ L(G).
During grammar induction each hybrid tree h = (s, ≤s ) of the corpus is decomposed.
A decomposition will determine the structure of a derivation of h by the grammar.
Classically, this decomposition and thereby the resulting derivations resemble the
structure of s. This approach has been pursued, for instance, by Charniak (1996) for
CFGs, and by Maier and Søgaard (2008) and Kuhlmann and Satta (2009) for LCFRSs.
There is no guarantee, however, that this approach is optimal from the perspective of, for
example, parsing efficiency, the grammar’s potential to generalize from training data, or
the size of the grammar.

487

Computational Linguistics

Volume 43, Number 3

For a more general approach that offers additional degrees of freedom we extend
the framework of Nederhof and Vogler (2014) and let grammar induction depend on a
decomposition strategy of the string str(h), called recursive partitioning. One may choose
one out of several such strategies. We consider four instances of induction of hybrid
grammars, which vary in the type of hybrid trees that occur in the corpus, and the type
of the resulting hybrid grammar:

1.
2.
3.
4.

corpus

hybrid grammar

phrase structures
phrase structures
dependency structures
dependency structures

LCFRS/sDCP
LCFRS/sCFTG
LCFRS/sDCP
LCFRS/sCFTG

6.1 Recursive Partitioning and Induction of LCFRS
A recursive partitioning of a string w of length n is a tree π whose nodes are labeled
with subsets of [n]. The root of π is labeled with [n]. Each leaf of π is labeled with a
singleton subset of [n]. Each non-leaf node has at least two children and is labeled with
the union of the labels of its children, which furthermore must be disjoint. To fit recursive
partitionings into our framework of s-terms, we regard P ([n]) as ranked alphabet with
P ([n]) = P ([n])(1) . We let π ∈ TP∗ ([n]) with |π| = 1.
We say a set J ⊆ [n] has fanout k if k is the smallest number such that J can be written
as J = J1 ∪ . . . ∪ Jk , where:

r
r

each J` (` ∈ [k]) is of the form {i` , i` + 1, . . . , i` + m` }, for some i` and
m` ≥ 0, and
i ∈ J` , i0 ∈ J`0 (`, `0 ∈ [k]) and ` < `0 imply i < i0 .

Note that J1 , . . . , Jk are uniquely defined by this, and we write spans(J) = hJ1 , . . . , Jk i. The
fanout of a recursive partitioning is defined as the maximal fanout of its nodes.
Figure 10 presents two recursive partitionings of a string with seven positions. The
left one has fanout 3 (because of the node label {1, 3, 6, 7} = {1} ∪ {3} ∪ {6, 7}), whereas
the right one has fanout 2.
Algorithm 2 constructs a LCFRS G out of a string w = α1 · · · αn and a recursive
partitioning π of w. The nonterminals are symbols of the form LJM, where J is a node

{1, 2, 3, 4, 5, 6, 7}
{1, 2, 3, 5, 6, 7}
{1, 3, 6, 7}
{1, 6}

{3, 7}

{1} {6} {3} {7}

{1, 2, 3, 4, 5, 6, 7}

{4}

{1, 2, 3, 5, 6, 7}

{2, 5}
{2}

{3, 7}
{5 }

{3}

{1, 2, 5, 6}
{7}

{1, 6}

{2, 5}

{1} {6} {2} {5}

Figure 10
Two examples of recursive partitionings of a string of length 7.

488

{4}

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

Algorithm 2 Induction of a LCFRS from a string and a recursive partitioning.
Input:
Output:
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:

a string w = α1 · · · αn ∈ Γ∗
a recursive partitioning π of w
a LCFRS G that parses w according to π; fanout of G equals fanout of π

function I NDUCE _LCFRS(w,π)
P←∅
for p ∈ pos(π ) do
j ← number of children of p in π
J0 ← π(p), J1 ← π(p11), . . . , Jj ← π(p1j)
if J0 = {i} for some i ∈ [n] then
P ← P ∪ {L{i}M(hαi i ) → hi}
else
for ` ∈ [j]0 do hJ`,1 , . . . , J`,k` i ← spans(J` )
P 1
for ` ∈ [j] do m` ← `−
j=1 kj

. set of LCFRS rules

for q ∈ [k0 ] do
let r and `1 , . . . , `r ∈ [j] and q1 ∈ [k`1 ], . . . , qr ∈ [k`r ] be such that
J0,q = J`1 ,q1 ∪ · · · ∪ J`r ,qr and i ∈ J`t ,qt , i0 ∈ J`t+1 ,qt+1 implies i < i0
sq ← hxm` +q1 , . . . , xm`r +qr i

11:
12:
13:

1

P ← P ∪ {LJ0 M(s1,k0 ) → hLJ1 M(x1,k1 ), . . . , LJj M(xmj +1,mj +kj )i}

14:

return G = (N, L[n]M, Γ, P),

15:

where N = {LJM | J is label in π}

label from π. (In practice, the nonterminals LJM are replaced by other symbols, as will
be explained in Section 6.8.) For each position p of π a rule is constructed. If p is a leaf
labeled by {i}, then the constructed rule simply generates αi where L{i}M has fanout
1 (lines 6 and 7). For each internal position labeled J0 and its children labeled J1 , . . . , Jj
we compute the spans of these labels (line 9). For each argument q of LJ0 M a s-term sq is
constructed by analyzing the corresponding component J0,q of spans(J0 ) (lines 12–13).
Here we exploit the fact that J0,q can be decomposed in a unique way into a selection of
sets that are among the spans of J1 , . . . , Jj . Each of these sets translates to one variable.
The resulting grammar G allows for exactly one derivation tree that derives w and has
the same structure as π. We say that G parses w according to π.
We observe that G as constructed in this way is in a particular normal form.3 To be
precise, by the notation in Equation (2) each rule satisfies one of the following:

r
r

n ≥ 2 and s1,k0 ∈ T∅∗ (Xmn ),
n = 0, k0 = 1, and s1 = hαi for some α ∈ Γ.

(structural rule)
(terminal generating rule)

Conversely, each derivation tree d of a LCFRS in normal form can be translated to
a recursive partitioning πd , by processing d bottom–up as follows. Each leaf, that is,
a rule A(hαi ) → hi, is replaced by the singleton set {i} where i is the position of the
corresponding occurrence of α in the accepted string. Each internal node is replaced by

3 See Seki et al. (1991) for an even stronger normal form.

489

Computational Linguistics

Volume 43, Number 3

the union of the sets that were computed for its children. For the constructed LCFRS G
that parses w according to π and for its only derivation tree d, we have π = πd .
Example 16
For a recursive partitioning of h s g in which the root has children labeled {1, 3} and {2},
Algorithm 2 constructs the LCFRS:
L{1, 2, 3}M(x1 x3 x2 ) → L{1, 3}M(x1 , x2 ) L{2}M(x3 )
L{1, 3}M(x1 , x2 ) → L{1}M(x1 ) L{3}M(x2 )
L{1}M(h) → hi L{2}M(s) → hi L{3}M(g) → hi
Alternatively, if we let Algorithm 2 run on the recursive partitioning of h s g in which the
root has children labeled {1, 2} and {3}, then it produces the following LCFRS, which is,
in fact, a CFG:
L{1, 2, 3}M(x1 x2 ) → L{1, 2}M(x1 ) L{3}M(x2 )
L{1, 2}M(x1 x2 ) → L{1}M(x1 ) L{2}M(x2 )
L{1}M(h) → hi L{2}M(s) → hi L{3}M(g) → hi
Observe that terminals are generated individually by the rules that were constructed
from the leaves of the recursive partitioning but not by the structural rules obtained from
internal nodes. Consequently, the LCFRS that we induce is in general not lexicalized. In
order to obtain a lexicalized LCFRS, the notion of recursive partitioning would need to
be generalized. We suspect that such a generalization is feasible, in conjunction with a
corresponding generalization of the induction techniques presented in this article. This
would be technically involved, however, and is therefore left for further research.
6.2 Construction of Recursive Partitionings
Figure 11 sketches three pipelines to induce a LCFRS from a hybrid tree, which differ
in the way the recursive partitioning is constructed. The first way (cf. Figure 11a) is
to extract a recursive partitioning directly from a hybrid tree (s, ≤s ). This extraction is
specified in Algorithm 3, which recursively traverses s. For each node in s, the gathered
input positions consist of those obtained from the children (lines 6 and 7), plus possibly
one input position from the node itself if its label is in Γ (line 5). The case distinction in
line 8 and following is needed because every non-leaf in a recursive partitioning must
have at least two children.
For a first example, consider the phrase structure in Figure 4a. The extracted recursive
partitioning is given at the beginning of Example 16. For a second example, consider the
dependency structure and the extracted recursive partitioning in Figure 12.
Note that if Algorithm 3 is applied to an arbitrary hybrid tree, then the accumulated
set of input positions is empty for those positions of s that do not dominate elements
with labels in Γ. The algorithm requires further (straightforward) refinements before
it can be applied on hybrid trees with several roots, that is, if |s| > 1. In much of what
follows, we ignore these special cases.
By this procedure, a recursive partitioning extracted from a discontinuous phrase
structure or a non-projective dependency structure will have a fanout greater than 1. By
then applying Algorithm 2, the resulting LCFRS will have fanout greater than 1. The
more discontinuity exists in the input structures, the greater the fanout will be of the

490

Gebhardt, Nederhof, and Vogler

(a)

(b)

(c)

hybrid
tree

hybrid
tree

Alg. 3

rec. par.

str

string

Alg. 3

rec. par.

str

string

Hybrid Grammars

Alg. 4

binary
rec. par.
with
fanout k

l/r-branching
rec. par.

hybrid
tree
str

unrestricted
LCFRS

Alg. 2

Alg. 2

binary
LCFRS
with
fanout k

Alg. 2

(reversed)
FA

string

Figure 11
Three pipelines for LCFRS induction.

recursive partitioning and the resulting LCFRS, which in turn leads to greater parsing
complexity. We therefore consider how to reduce the fanout of a recursive partitioning,
before it is given as input to Algorithm 2. We aim to keep the structure of a given
recursive partitioning largely unchanged, except where it exceeds a certain threshold on
the fanout.
Algorithm 4 presents one possible such procedure. It starts at the root, which by
definition has fanout 1. Assuming the fanout of the current node does not exceed k, then
there are two cases to be distinguished. If the label J of the present node is a singleton,

Algorithm 3 Extraction of recursive partitioning from hybrid tree
Input:
Output:

a hybrid tree h = (s, ≤s ) with posΓ (s) = {p1 , . . . , pn }
where pi ≤s pi+1 for each i ∈ [n − 1]
a recursive partitioning of str(h)

function EXTRACT _ RECURSIVE _ PARTITIONING(h)
return REC _ PAR(1)
3: function REC _ PAR (p)
4:
w ← hi
5:
if p = pi ∈ posΓ (s) then w ← h{i}i
1:
2:

6:
7:
8:
9:
10:
11:
12:

. p ∈ pos(s)
. w ∈ TP∗ ([n])

for p0 ∈ children(p) do
w ← w · REC _ PAR (p0 )
if |w| ≤ 1 then return w
else
S|w|
U ← j=1 w(j)
sort w such that min(w(j)) < min(w(j + 1))
return hU(w)i

491

Computational Linguistics

Volume 43, Number 3

{1, 2, 3, 4, 5, 6}

zag
Jan

helpen
Piet

{1}

{2, 3, 5, 6}

{4 }

lezen

{2}

{3, 6}

{5 }

Marie
Jan
(1)

Piet Marie zag helpen lezen
(2)
(3)
(4)
(5)
(6)

{3} {6}

Figure 12
A dependency structure and the recursive partitioning extracted from it by Algorithm 3.

then the node is a leaf, and we can stop (lines 2–3). Otherwise, we search breadth-first
through the subtree rooted in the present node to identify a descendant p such that both
its label J0 and J \ J0 have fanout not exceeding k (line 4). It is easy to see that such a
node always exists: Ultimately, breadth-first search will reach the leaves, which are each
labeled with a single number. One of these numbers must match either the lowest or
the highest element of some maximal subset of consecutive numbers from J, so that the
fanout of J cannot increase if that number is removed.
The current node is now given two children π|p and t. The first is the subtree rooted
in the node labeled J0 that we identified earlier, and the second is a copy of the subtree
rooted in the present node, but with J0 subtracted from the label of every node (lines 7–14).
Nodes labeled with the empty set are removed (line 10), and if a node has the same label

Algorithm 4 Transformation of recursive partitioning
Input:
Output:

a recursive partitioning π of a string of length n
an integer k ≥ 1
a binary recursive partitioning π0 of fanout no greater than k

function T RANSFORM(π = hJ(ht1 , . . . , tm i )i)
if |J| = 1 then
return hJ(hi )i
4:
breadth-first search p in pos(π ) \ {1} such that π(p) and J \ π(p) have fanout ≤ k
5:
t ← F ILTER (π(p), π )
6:
return hJ(T RANSFORM (hπ|p i ), T RANSFORM (t))i

1:
2:
3:

7:
8:
9:
10:
11:
12:
13:
14:

492

function F ILTER(J0 , π = hJ(ht1 , . . . , tm i )i)
F ← J \ J0
if |F| = 1 then
return hF(hi )i
else if |F| = 0 then return hi
else
s ← F ILTER (J0 , ht1 i ) · . . . · F ILTER (J0 , htm i )
if |s| = 1 then
return s
else
return hF(s)i

. J0 ⊆ [n], π ∈ TP∗ ([n])

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

as its parent then the two are collapsed (line 13). As the two children each have fanout
not exceeding k, we can apply the procedure recursively (line 6).
Example 17
The recursive partitioning π in the left half of Figure 10 has a node labeled {1, 3, 6, 7}, with
fanout 3. With J = {1, 2, 3, 5, 6, 7} and k = 2, one possible choice for J0 is {3, 7}, as then
both J0 and J \ J0 = {1, 2, 5, 6} have fanout not exceeding 2. This leads to the partitioning
π0 in the right half of the figure. Because now all node labels have fanout not exceeding
2, recursive traversal will make no further changes. The partitioning π0 is similar to π
in the sense that subtrees that are not on the path to {3, 7} remain unchanged. Other
valid choices for J0 would be {2} and {5}. Not a valid choice for J0 would be {1, 6}, as
J \ {1, 6} = {2, 3, 5, 7}, which has fanout 3.
Algorithm 4 ensures that subsequent induction of an LCFRS (cf. Figure 11b) leads
to a binary LCFRS. Note the difference between binarization algorithms such as those
from Gómez-Rodríguez and Satta (2009) and Gómez-Rodríguez et al. (2009), which are
applied on grammar rules, and our procedure, which is applied before any grammar
is obtained. Unlike van Cranenburgh (2012), moreover, our objective is not to obtain a
“coarse” grammar for the purpose of coarse-to-fine parsing.
Note that if k is chosen to be 1, then the resulting partitioning is consistent with
derivations of a CFG. Even simpler partitionings exist. In particular, the left-branching
partitioning has internal node labels that are {1, 2, . . . , m}, each with children labeled
{1, . . . , m − 1} and {m}. These are consistent with the computations of finite automata
(FA) in reverse direction; see Figure 11c. Similarly, there is a right-branching recursive
partitioning, reflecting finite-state processing in a forward direction. The use of branching
partitionings completely detaches string parsing from the structure of the given hybrid
tree.
Example 18
The right-branching recursive partitioning for the dependency structure in Figure 12
and the transitions of the FA obtained from it are depicted in Figure 13. The FA can
be obtained via a LCFRS that is induced from the recursive partitioning, as usual. By
construction it is equivalent to a right-linear CFG, with rules:
L{i, i + 1 . . . , 6}M(x1 x2 ) → hL{i}M(x1 ), L{i + 1, . . . , 6}M(x2 )i
for each i ∈ [5], and L{i}M(αi ) → hi for each i ∈ [6].
The relation between recursive partitioning and worst-case parsing complexity of
the induced LCFRS is summarized in Table 1. We remark that the parsing complexity for

{1, 2, 3, 4, 5, 6}
{1 }

{2, 3, 4, 5, 6}
{2}

1–6

{3, 4, 5, 6}
{3}

{4, 5, 6}
{4}

∅

Jan
lezen

2–6
6

Piet
helpen

3–6
5–6

Marie

4–6

zag

{5, 6}
{5}

{6}

Figure 13
A right-branching recursive partitioning and an FA.

493

Computational Linguistics

Volume 43, Number 3

Table 1
Induction pipeline (from Figure 11) and type and worst-case parsing complexity of the induced
LCFRS. Here k and m denote the fanout and the maximum length of any right-hand side of the
LCFRS, respectively.
Pipeline

Type of the induced LCFRS

Parsing complexity for string of length n

(a)
(b) k ≥ 1
(b) k = 1
(c) right
(c) left

LCFRS of arbitrary k and m
binarized k-LCFRS
binarized CFG
FA
(reverse) FA

O(n(m+1)·k )
O(n3k )
O(n3 )
O(n)
O(n)

unrestricted LCFRSs would improve from O(n(m+1)·k ) to O(n2·k+2 ) if we could ensure
that the LCFRSs are well-nested (Gómez-Rodríguez, Kuhlmann, and Satta 2010), or in
other words, if we replace LCFRSs by sMGs. How to refine pipeline (a) to achieve this is
left for future investigation.
6.3 Induction of Hybrid Grammars
In the remainder of Section 6 we extend the induction pipelines for LCFRS to induction
pipelines for LCFRS/sDCP hybrid grammars, as illustrated in Figure 14. Given a hybrid
tree h = (s, ≤s ), we choose a recursive partitioning π obtained in one of the ways
discussed in the previous section. We apply Algorithm 2 to induce a LCFRS G1 that
generates str(h). Using the same recursive partitioning π, we induce a sDCP G2 that
generates s. For this we use either Algorithm 5 or 6, depending on whether h is a phrase
structure or a dependency structure.
Then we combine both grammars into a hybrid grammar G, which synchronously
generates the hybrid tree h. For this, we synchronize terminals and nonterminals of G1
and G2 (via indexed symbols) by slightly changing Algorithm 2. Because the terminals
that require synchronization are only generated by the rules constructed for the leaves of
π, we alter line 7 to
1
P ← P ∪ {L{i}M(αi ) → hi}
Likewise, we need to index the nonterminals on the right-hand side of each structural
rule, that is, we alter line 14 to
1

j

P ← P ∪ {LJ0 M(s1,k0 ) → hLJ1 M (x1,k1 ), . . . , LJj M (xmj +1,mj +kj )i}

hybrid tree

create recursive partitioning

Alg. 2

hybrid grammar

str
Alg. 5/
Alg. 6
Figure 14
Pipeline for the induction of LCFRS/sDCP hybrid grammars.

494

LCFRS

sDCP

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

The corresponding indexing needed in G2 will be described in Sections 6.4
and 6.6.
In preparation, we define several notions to relate labels of the recursive partitioning
with subsets of the positions of s. Let posΓ (s) = {p1 , . . . , pn } with pi ≤s pi+1 (i ∈ [n − 1])
and let J be a label of π. We define the set Π(J) = {pi | i ∈ J}, which identifies the nodes
of s corresponding to the elements in J. For any subset U ⊆ pos(s), we construct the sets
>(U) and ⊥(U), which, intuitively, delimit U from the top and the bottom, respectively.
Formally, p ∈ >(U) if and only if p ∈ U and parent(p) ∈
/ U. We have p ∈ ⊥(U) if and only
if parent(p) ∈ U and p ∈
/ U.
6.4 Induction of LCFRS/sDCP Hybrid Grammars from Phrase Structures
Grammar induction is relatively straightforward for a given hybrid tree h = (s, ≤s ) that
is a phrase structure, and a given recursive partitioning π. For each node of π, its label is
a set of positions of str(h), and these positions must each correspond to a leaf node of s,
by virtue of h being a phrase structure. We can apply a closure operation on this set of
leaf nodes that includes a node if all of its children are included. Formally, let J be a label
of π. Then C(J) is the smallest set U ⊆ pos(s) satisfying (i) Π(J) ⊆ U and (ii) if p ∈ pos(s),
children(p) 6= ∅, and children(p) ⊆ U, then p ∈ U.
The set C(J) corresponds to a set of (maximal, disjoint) sub-s-terms of s, that is, C(J)
can be partitioned such that each part contains the positions that correspond to one
sub-s-term. These parts can be arranged according to the lexicographical ordering on
positions in s. Formally, for each set U ⊆ pos(s), we define s-rk(U) to be the maximal
number k such that U can be partitioned into sets U1 , . . . , Uk where:

r
r

for every i ∈ [k], p ∈ Ui , and p0 ∈ U if p0 = parent(p) or p0 = right-sibling(p),
then p0 ∈ Ui , and
for every i, j ∈ [k], p ∈ Ui , and p0 ∈ Uj we have p ≤` p0 implies i ≤ j.

Note that U1 , . . . , Uk are uniquely defined by this, and we write gspans(U) = hU1 , . . . , Uk i.
The function “gspans” generalizes “spans,” which we defined for recursive partitioning
earlier. Similarly, s-rk as used here generalizes the notion of fanout as used for node
labels of a recursive partitioning.
These concepts allow us to define a mapping from a node J in π to the set gspans(C(J))
of positions of s. This mapping is such that if J1 , . . . , Jm are the child nodes of node J in π,
(i)
(0)
then each set Uj in gspans(C(Ji )) (i ∈ [m], j ∈ [s-rk(Ji )]) is contained in some set Uq in
gspans(C(J)) (q ∈ [s-rk(J)]). A different way of looking at this is that the image of J can
be constructed out of the images of Ji (i ∈ [m]), possibly by adding further nodes linking
existing sub-s-terms together.
Such composition of s-terms into larger s-terms is realized by a sDCP without
inherited arguments, as constructed by Algorithm 5. It builds one production for
(0)
each node J0 with children J1 , . . . , Jm . J0 has a synthesized attribute for each set Uq
in gspans(C(J0 )). The corresponding s-term sq is constructed by traversing the positions
(0)
(i)
in Uq (lines 18–31). A sequence of consecutive positions that are also in some Uj
(i)

in gspans(C(Ji )) is realized by a single variable xj (lines 21–24). Remaining positions
become nodes of sq (lines 26–30).
In order to create a hybrid rule as outlined in Section 6.3, we need to introduce
indexing of nonterminals and terminals in the sDCP. Synchronized terminals are only

495

Computational Linguistics

Volume 43, Number 3

Algorithm 5 Induction of a sDCP from a phrase structure and a recursive partitioning
Input:

Output:
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:

19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:

496

a phrase structure h = (s, ≤s ) with posΓ (s) = {p1 , . . . , pn }
where pi <s pi+1 for each i ∈ [n − 1]
a recursive partitioning π of str(s)
a sDCP G that generates s according to π

function C ONSTRUCT _ S DCP((s, ≤s ),π)
P←∅
for p ∈ pos(π ) do
m ← number of children of p in π
J0 ← π(p), J1 ← π(p11), . . . , Jm ← π(p1m)
if J0 = {i} for some i ∈ [n] then
hU1(0) i ← gspans(C(J0 ))
{p} ← >(U1(0) )
P ← P ∪ {LJ0 M(hs|p i ) → hi}
else
hU1(0) , . . . , Uk(0)
0 i ← gspans(C(J0 ))

. set of sDCP rules

0

hU1(i) , . . . , Uk(i)i i ← gspans(C(Ji )) for each i ∈ [m]
for q ∈ [k00 ] do
(0)
pmin ← min≤` (Uq )
(0)
(i)
sq ← C ONSTR ST ERM (pmin , Uq , (Uj | i ∈ [m], j ∈ [ki ]))
(1)

(m)

P ← P ∪ {LJ0 M(s1,k00 ) → hLJ1 M(x1,k1 ), . . . , LJm M(x1,km )i}

return G = (N, L[n]M, Σ, P),

where N = {LJM | J label in π}

(0)

(i)

function C ONSTR ST ERM(p, Uq , (Uj | i ∈ [m], j ∈ [ki ]))

. p ∈ pos(s), Uq(0) ⊆ pos(s), (Uj(i) | i ∈ [m], j ∈ [ki ]) family of subsets of pos(s)
s0 ← ε
(0)
while p ∈ Uq do
(i)
if p ∈ Uj for some i ∈ [m], j ∈ ki then
(i)

s0 ← s0 · hxj i
(i)

while p ∈ Uj do
p ← right-sibling(p)
else
p0 ← min≤` (children(p))
(0)
(i)
c ← C ONSTR ST ERM (p0 , Uq , (Uj | i ∈ [m], j ∈ [ki ]))
σ ← s(p)
s0 ← s0 · hσ(c)i
p ← right-sibling(p)
return s0

Gebhardt, Nederhof, and Vogler

h{pVP , pV , pADV , ph , pg , ps }i

{1, 2, 3}
{1, 2}
{1 }

Hybrid Grammars

{3}

gspans ◦ C

h{ph }, {pADV , ps }i
h{ph }i

{2}

h{pg }i

h{pADV , ps }i

Figure 15
The left-branching recursive partitioning of {1, 2, 3} and the image under gspans after C.

generated by the rules constructed for the leaves of π. Hence, we alter line 9 in
Algorithm 5 to:
1

P ← P ∪ {LJ0 M(hs[s(pi ) ]pi |p i ) → hi}
that is, we add an index to the symbol at position pi before selecting the relevant subtree
s|p of s. For the indexing of nonterminals, we change line 16 to:
1

(1)

m

(m)

P ← P ∪ {LJ0 M(s1,k00 ) → hLJ1 M (x1,k1 ), . . . , LJm M (x1,km )i}
Example 19
Consider the hybrid tree h in Figure 4a, in combination with the recursive partitioning
extracted from the hybrid tree by Algorithm 3. The children of the root are {1, 3}
and {2}. The relevant s-term for {1, 3} is V(hat, gearbeitet) and the s-term for {2} is
ADV(schnell). Application of Algorithm 5 yields the sDCP grammar:
L{1, 2, 3}M(VP(x1 x2 )) → L{1, 3}M(x1 ) L{2}M(x2 )
L{1, 3}M(V(x1 x2 )) → L{1}M(x1 ) L{3}M(x2 )
L{1}M(h) → hi L{2}M(ADV(s)) → hi L{3}M(g) → hi
Synchronizing this sDCP with the first LCFRS of Example 16 yields the following
LCFRS/sDCP hybrid grammar:
[L{1, 2, 3}M(x1 x3 x2 ) → L{1, 3}M 1 (x1 , x2 ) L{2}M 2 (x3 ) ,

L{1, 2, 3}M(VP(x1 x2 )) → L{1, 3}M 1 (x1 ) L{2}M 2 (x2 )]

[L{1, 3}M(x1 , x2 ) → L{1}M 1 (x1 ) L{3}M 2 (x2 ) ,

L{1, 3}M(V(x1 x2 )) → L{1}M 1 (x1 ) L{3}M 2 (x2 )]
1

1

[L{1}M(h ) → hi , L{1}M(h ) → hi]
[L{2}M(s 1 ) → hi , L{2}M(ADV(s 1 )) → hi]
[L{3}M(g 1 ) → hi , L{3}M(g 1 ) → hi]
The fanout of the LCFRS is 2 and the s-rank of the sDCP is 1.
Example 20
Consider again the hybrid tree in Figure 4a, but now in combination with the recursive
partitioning shown in Figure 15, that is, the left-branching partitioning of {1, 2, 3}. The
relevant disjoint subtrees for {1, 2} are hat and ADV(schnell) and the one for {3} is
gearbeitet. (In a real-world grammar we would have parts of speech occurring above all

497

Computational Linguistics

Volume 43, Number 3

the words.) Applying Algorithm 5 and synchronizing the resulting sDCP grammar with
the second LCFRS of Example 16 yields the following LCFRS/sDCP hybrid grammar:

[L{1, 2, 3}M(x1 x2 ) → L{1, 2}M 1 (x1 ) L{3}M 2 (x2 ) ,

L{1, 2, 3}M(VP(V(x1 x3 )x2 )) → L{1, 2}M 1 (x1 , x2 ) L{3}M 2 (x3 )]

[L{1, 2}M(x1 x2 ) → L{1}M 1 (x1 ) L{2}M 2 (x2 ) ,

L{1, 2}M(x1 , x2 )) → L{1}M 1 (x1 ) L{2}M 2 (x2 )]
1

1

[L{1}M(h ) → hi , L{1}M(h ) → hi]
[L{2}M(s 1 ) → hi , L{2}M(ADV(s 1 )) → hi]
[L{3}M(g 1 ) → hi , L{3}M(g 1 ) → hi]
The fanout of the LCFRS is 1 and the s-rank of the sDCP is 2.
Figure 16 compares the two derivation trees of the LCFRS/sDCP hybrid grammars
of Examples 19 (left) and 20 (right).
We observe the following general property of Algorithm 5: If the recursive partitioning extracted by Algorithm 3 is given as input, then each nonterminal of the
induced sDCP G has s-rank 1 (as in Example 19). This coincides with pipeline (a)
of Figure 11, that is, the induction of a LCFRS of arbitrary fanout. However, if
the recursive partitioning is transformed by Algorithm 4 or if the left-branching or
right-branching recursive partitioning is used (as in Example 20 and as in pipelines (b)
and (c) of Figure 11), then the fanout of the induced LCFRS decreases and its derivations
are binarized. At the same time, the numbers of synthesized arguments in the induced
sDCP may increase. In other words, we witness a trade-off between the degree of mild
context-sensitivity of the LCFRS and the numbers of arguments of the sDCP.
We conclude:

VP

VP

{1, 2, 3} x1 x3 x2

x1

{1, 2, 3} x1 x2

{1, 3}

x1

{1 } h 1

x1
x1

x2
x2

x3
{2} s 2

x1
V
x1

x2

x1

x2

x2

1

{3} g 3

g3

h

x2

V

x2

x2
ADV

x1
{1, 2} x1 x2

s2
x1
{1} h 1

x1
h

1

x1
x1

x3

x2
{3} g 3

x2
x2

x2
{2} s 2

x1

x3
g3

x2
ADV
s2

Figure 16
(Left) The only derivation tree of the LCFRS/sDCP hybrid grammar induced in Example 19 with
the recursive partitioning extracted from the hybrid tree. (Right) The only derivation tree of the
LCFRS/sDCP hybrid grammar induced in Example 20 with the left-branching recursive
partitioning.

498

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

Theorem 3
For each phrase structure h and recursive partitioning π of str(h), we can construct a
LCFRS/sDCP hybrid grammar G such that G generates h and parses str(h) according to
π. Moreover, the sDCP that is the second component only has synthesized arguments.
6.5 Induction of LCFRS/sCFTG Hybrid Grammars from Phrase Structures
Given a recursive partitioning π and a phrase structure h = (s, ≤s ), the construction in
Section 6.4 relied on a mapping from a node of π labeled J to sets of positions of maximal
sub-s-terms in s whose yields together cover exactly the positions in J. We now say π
is chunky with respect to h if, for each node J of π, we have s-rk(C(J)) = 1, that is, the
nodes in its image under the mapping form a single sub-s-term. If π is chunky with
respect to h, then each sDCP nonterminal in the construction from Section 6.4 will have
a single synthesized argument. A sDCP with this property is equivalent to a sCFTG in
which all nonterminals have rank 0, that is, a regular tree grammar. Therefore:
Theorem 4
For each phrase structure h and recursive partitioning π of str(h) that is chunky with
respect to h, we can construct a LCFRS/sCFTG hybrid grammar G such that G generates
h and parses str(h) according to π. Moreover, the second component of G is a regular tree
grammar.
6.6 Induction of LCFRS/sDCP Hybrid Grammars from Dependency Structures
Let h = (s, ≤s ) be a hybrid tree over (Σ, Σ ), or in other words, a dependency structure,
and let π be a recursive partitioning of str(h). The task is to construct a LCFRS/sDCP
hybrid grammar that generates h and parses str(h) according to π.
In the case of phrase structures, we could identify entire subtrees of s whose yields
corresponded to subsets of node labels of π. A sequence of consecutive such subtrees
(i.e., whose roots were siblings) was then translated to a synthesized argument of a sDCP
rule. With dependency structures, however, we need to allow for the scenario where
we have a label J of a node in π and two positions p and p0 in s with parent(p0 ) = p, and
p ∈ Π(J) whereas p0 ∈
/ Π(J). Thus we will need to consider a subtree of s rooted in p, with
a “gap” for child p0 . This gap will be implemented by introducing an inherited argument
in the sDCP, so that the gap can be filled by a structure built elsewhere.
Like the induction algorithms considered before, Algorithm 6 constructs a rule for
each node p of π. If p is a leaf of π (line 6), labeled with a singleton J0 = {i}, we construct
the sDCP rule LJ0 M(x1 , hα(hx1 i )i ) → hi, where α is the i-th element of str(h), assuming the
node labeled α is not a leaf in s (line 10). The i-rank of LJ0 M is 1. Coupled to the corresponding LCFRS rule, this creates the hybrid rule [LJ0 M(hα 1 i ) → hi, LJ0 M(x1 , hα 1 (hx1 i )i ) → hi].
If the node labeled α is a leaf of s, we can dispense with the inherited argument of LJ0 M in
the second component and replace α(hx1 i ) by α (line 8).
If p is an internal node of π, then we proceed as follows. We determine the set
Π(J0 ) of positions of s that correspond to the numbers in the label of p. We compute
the sets of positions >(Π(J0 )) and ⊥(Π(J0 )) that delimit Π(J0 ) from the top and bottom,
respectively. We bundle consecutive positions in >(Π(J0 )) and ⊥(Π(J0 )) by applying
gspans. For brevity, we write >max (J0 ) instead of gspans(>(Π(J0 ))) and ⊥max (J0 ) instead
of gspans(⊥(Π(J0 ))). The nonterminal LJ0 M is given a synthesized attribute for each set
(0)
(0)
Iq in >max (J0 ) (line 12), and an inherited attribute for each set Oj in ⊥max (J0 ) (line 13).
499

Computational Linguistics

Volume 43, Number 3

Algorithm 6 Induction of a sDCP from a dependency structure and a recursive
partitioning
Input:

Output:
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:

a dependency structure h = (s, ≤s ) with pos(s) = {p1 , . . . , pn }
where pi <s pi+1 for each i ∈ [n − 1]
a recursive partitioning π of str(s)
a sDCP G that generates s according to π

function C ONSTRUCT _ S DCP((s, ≤s ),π)
P←∅
for p ∈ pos(π ) do
m ← number of children of p in π
J0 ← π(p), J1 ← π(p11), . . . , Jm ← π(p1m)
if J0 = {i} for some i ∈ [n] and s(pi ) = α then
if children(pi ) = ∅ then
R ← R ∪ {LJ0 M(hαi ) → hi}
else
R ← R ∪ {LJ0 M(x1 , hα(hx1 i )i ) → hi}
else
hI1(0) , . . . , Ik(0)
0 i ← >max (J0 )

. set of sDCP rules

0

hO1(0) , . . . , Ok(0)
i ← ⊥max (J0 )
0

hO1(i) , . . . , Ok(i)i i ← >max (Ji ) for each i ∈ [m]

hI1(`) , . . . , Ik(`0 ) i ← ⊥max (J` ) for each ` ∈ [m]
i
for each ` ∈ [m]0 and q ∈ [k`0 ] do
(` )
(` )
(i)
sq ← C ONSTR ST ERM (Iq , (Oj | i ∈ [m]0 , j ∈ [ki ]))
(0)

(0)

(1)

(1)

(m)

(m)

P ← P ∪ {LJ0 M(x1,k0 , s1,k0 ) → hLJ1 M(s1,k0 , x1,k1 ), . . . , LJm M(s1,k0 , x1,km )i}
0

return G = (N, L[n]M, Σ, P),

m

1

where N = {LJM | J label in π}

(i)

function C ONSTR ST ERM(I, (Oj | i ∈ [m]0 , j ∈ [ki ]))

. I ⊆ pos(s), (Oj(i) | i ∈ [m]0 , j ∈ [ki ]) family of subsets of pos(s)

21:
22:
23:
24:

s0 ← ε
while I 6= ∅ do
p ← min≤` (I)
(i)
let i in [m]0 and j in [ki ] such that p ∈ Oj
(i)

25:

I ← I \ Oj

26:

s0 ← s0 · hxj i

27:

(i)

return s0

(i)

(` )

Analogously, we determine sets Oj and Iq of positions of s for each child of p
(i)
(i)
labeled Ji (lines 14–15). Each set Oj corresponds to a distinct variable xj in the sDCP
(` )
(` )
rule. Each set Iq corresponds to a s-term sq which combines variables. In particular,
(` )
(i)
(i)
each set Iq is the (disjoint) union of some of the sets Oj . Conversely, each set Oj is
(` )
disjoint with all but one of the sets Iq . This fact is used in lines 20–27 to construct the

500

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

(` )

s-term sq . Having specified the variables and s-terms, the construction of the sDCP rule
is completed in line 18. Much as in Section 6.4, this sDCP rule can be coupled to the
corresponding LCFRS rule to form a hybrid rule.
Example 21
Figure 17 presents part of the hybrid tree from Figure 4b, together with part of a recursive
partitioning. Let us use the symbols pP , pM , ph , pl for the four positions in the hybrid tree
corresponding to the string positions 2, 3, 5, 6. Naturally, Π({2, 3, 5, 6} ) = {pP , pM , ph , pl },
Π({2, 6} ) = {pP , pl }, Π({3, 5} ) = {pM , ph }.
If we investigate which nodes in the hybrid tree delimit these sets from the top and
from the bottom, we obtain:

>(Π({2, 3, 5, 6} )) = {ph } >(Π({2, 6} )) = {pP , pl } >(Π({3, 5} )) = {pM , ph }
⊥(Π({2, 3, 5, 6} )) = ∅

⊥(Π({2, 6} )) = {pM }

⊥(Π({3, 5} )) = {pP , pl }

We obtain maximal sets of consecutive positions by:

>max ({2, 3, 5, 6} ) = h{ph }i >max ({2, 6} ) = h{pP , pl }i >max ({3, 5} ) = h{pM }, {ph }i
⊥max ({2, 3, 5, 6} ) = hi

⊥max ({2, 6} ) = h{pM }i

⊥max ({3, 5} ) = h{pP , pl }i

One constructed hybrid rule is therefore:
1

2

[L{2, 3, 5, 6}M(x1 x3 , x4 x2 ) → L{2, 6}M (x1 , x2 ) L{3, 5}M (x3 , x4 ),
1

2

L{2, 3, 5, 6}M(x3 ) → L{2, 6}M (x2 , x1 ) L{3, 5}M (x1 , x2 , x3 )]
The first component was constructed as in previous sections. In the second component,
the i-rank of L{2, 3, 5, 6}M is 0 as ⊥max ({2, 3, 5, 6} ) has length 0. The i-rank of L{3, 5}M is 1 as
⊥max ({3, 5} ) contains a single set {pP , pl }, whereas its s-rank is 2 as >max ({3, 5} ) contains
two sets. Because the first (and only) set of ⊥max ({2, 6} ), namely {pM }, equals the first
set of >max ({3, 5} ), the variable x2 is shared between the inherited argument of L{2, 6}M
and the first synthesized argument of L{3, 5}M.
helpen
Piet

{2, 3, 5, 6}

lezen

{2, 6}

Marie
Jan Piet Marie zag helpen lezen
(2)

(3)

(5)

{2}

{3, 5}
{6}

{3}

{5}

(6)

Figure 17
Part of a hybrid tree and part of a recursive partitioning.

501

Computational Linguistics

Volume 43, Number 3

Some other rules in this example are:
1

2

1

2

1

2

[L{2, 6}M(x1 , x2 ) → L{2}M (x1 ) L{6}M (x2 ) , L{2, 6}M(x1 , x2 x3 ) → L{2}M (x2 ) L{6}M (x1 , x3 )]
1

2

[L{3, 5}M(x1 , x2 ) → L{3}M (x1 ) L{5}M (x2 ) , L{3, 5}M(x1 , x2 , x3 ) → L{3}M (x2 ) L{5}M (x1 , x3 )]
1

1

[L{5}M(helpen ) → hi , L{5}M(x1 , helpen (x1 )) → hi]

For the second component of the first hybrid rule, we remark that ⊥max ({6} ) = h{pM }i
and therefore L{6}M has i-rank 1. Further, >max ({2} ) = h{pP }i, >max ({6} ) = h{pl }i, and
we already saw that >max ({2, 6} ) = h{pP , pl }i. The fact that {pP , pl } = {pP } ∪ {pl } and
pP <` pl explain the concatenation x2 x3 in the only synthesized argument in the left-hand
side. Figure 18 shows the derivation tree that is induced by the sDCP rules on the given
recursive partitioning (again abbreviating each Dutch word by its first letter).
We conclude:
Theorem 5
For each dependency structure h and recursive partitioning π of str(h), we can construct
a LCFRS/sDCP hybrid grammar G such that G generates h and parses str(h) according
to π.
6.7 Induction of LCFRS/sCFTG Hybrid Grammars from Dependency Structures
For dependency structures, we can define a notion of chunkiness similar to that in
Section 6.5, relying on the definitions in Section 6.4. We say a recursive partitioning
π with respect to dependency structure h = (s, ≤s ) is chunky if for every node label J
of π the length of >max (J) is 1. We have seen in Section 6.4 that the length of >max (J)
determines the fanout of the corresponding nonterminal in the second component of

L{2, 3, 5, 6}M x3

x2
x1
x2
L{2}M P

x1
L{2, 6}M x2 x3

x1
x1

x1
x1
x3
L{6}M l(x1 )

L{3}M

x2
M

x2 x3
L{3, 5}M x2 x3

x1
x1

L{5}M

Figure 18
Derivation tree for the recursive partitioning of Figure 17, induced by the sDCP rules.

502

x3
h(x1 )

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

the constructed hybrid rule. We observed before that a sDCP grammar in which all
nonterminals have s-rank 1 is equivalent to a sCFTG. We may conclude:
Theorem 6
For each dependency structure h and recursive partitioning π of str(h) that is chunky
with respect to h, we can construct a LCFRS/sCFTG hybrid grammar G such that G
generates h and parses str(h) according to π.
6.8 Induction on a Corpus
In the previous sections, we have induced a LCFRS/sDCP hybrid grammar G from a
single phrase structure or dependency structure h. Given a training corpus c of phrase
structures or dependency structures, we now want to induce a single hybrid grammar G
that generalizes over the corpus. To this end, we apply one of the induction techniques
to each hybrid tree h in c. The resulting grammars are condensed into a single hybrid
grammar G by relabeling the existing nonterminals of the form LJM. This relabeling
should be according to a naming scheme that is consistent to ensure that hybrid rules
constructed from one hybrid tree for adjacent nodes of π can still link together to form a
derivation. Beyond that, the naming scheme shall also allow for interaction of rules that
were constructed from different hybrid trees, such that L(G) contains meaningful hybrid
trees that were not in c.
Two such naming schemes were considered in Nederhof and Vogler (2014) for a
corpus of phrase structures. By strict labeling, a nonterminal name is chosen to consist
of the terminal labels at the roots of the relevant subtrees of s. In Example 20, therefore,
we would replace L{1, 2}M by hhat, ADVi. (In a more realistic grammar, we would likely
have a part of speech instead of hat.) This tends to lead to many nonterminal labels for
different combinations of terminals. Therefore, an alternative was considered, called
child labeling. This means that for two or more consecutive siblings in s, we collapse
their sequence of terminals into a single tag of the form children-of(X), where X is the
terminal label of the parent. This creates much fewer nonterminal names, but confuses
different sequences of terminals that may occur below the same terminal. For more
details, we refer the reader to Nederhof and Vogler (2014).
For grammar induction with a corpus of dependency structures, there is the
additional complication of inherited arguments. If a LCFRS/sDCP hybrid grammar
is induced from a single dependency structure, using nonterminals of the form LJM as
in Section 6.6, then cycles cannot occur in derivations of the sDCP. This is because, by
definition, no cycles occur in the given dependency structure. However, if we replace
nonterminals of the form LJM by any other choice of symbols, and combine rules induced
by different hybrid trees from a corpus, then cycles may arise if the relationship between
inherited and synthesized arguments is confused.
One solution is to encode the dependencies between inherited and synthesized
attributes into the nonterminal names—that is, for each synthesized attribute the list of
inherited attributes from which it receives subtrees is specified (Angelov et al., 2014).
Conceptually this is close to the g functions in the proof of Theorem 2 in Appendix C.
One way to formalize this encoding is as follows.
As explained in Section 6.6, if we have a node label J in π, and ⊥max (J) = hO1 , . . . , Ok i
and >max (J) = hI1 , . . . , Ik0 i, then this leads to creation of a nonterminal with k inherited
arguments and k0 synthesized arguments, so in total k + k0 arguments. We can construct a
∗
0
s-term σ in T[k
+k0 ] , in which every number in [k + k ] occurs exactly once. In σ, argument
numbers are located relative to one another as the corresponding positions in ⊥max (J) ·
503

Computational Linguistics

Volume 43, Number 3

>max (J) are located in the hybrid tree. More precisely, if the i-th element and the j-th
element of ⊥max (J) · >max (J) represent positions that share a parent, and those positions
of the i-th precede those of the j-th, then number i precedes j in the root of the same
sub-s-term of σ. Similarly, if the positions of the j-th element are descendants of at least
one position in the i-th element, then j occurs as a descendant of i in σ.
Example 22
In combination with strict labeling, the nonterminal L{3, 5}M in Example 21 could be
replaced by hPiet lezen, Marie, helpen, σi, where σ is the s-term 3(1(2)). The “3” (third
argument of the nonterminal) stands for the node in the hybrid tree labeled with helpen.
Descendants of this node are the two nodes labeled with Piet and lezen, which belong to
the first argument. The “2” (second argument) stands for the node labeled Marie, which
is a descendant of lezen and therefore occurs below the “1.”
7. Experiments
In this section, we present the first experimental results on induction of LCFRS/sDCP
hybrid grammars from dependency structures and their application to parsing. We
further present experiments on constituent parsing similar to those of Nederhof and
Vogler (2014), but now with a larger portion of the TIGER corpus (Brants et al. 2004).
The purpose of the experiments is threefold: (i) A proof-of-concept for the induction
techniques developed in Section 6 is provided. (ii) The influence of the strategy of recursive partitioning is evaluated empirically, as is the influence of the nonterminal naming
scheme. We are particularly interested in how the strategy of recursive partitioning
affects the size, parse time, accuracy, and robustness of the induced hybrid grammars.
(iii) The performance of our architecture for syntactic parsing based on LCFRS/sDCP
hybrid grammar is compared with two existing parsing architectures.
For all experiments, a corpus is split into a training set and a test set. A LCFRS/sDCP
hybrid grammar is induced from the training set. Probabilities of rules are determined
by relative frequency estimation. The induced grammar is then applied on each sentence
of the test set (see Section 5.3), and the parse obtained from the most probable derivation
is compared with the gold standard, resulting in a score for each sentence. The average
of these scores for all test sentences is computed, weighted by sentence length.
All algorithms are implemented in Python and experiments are run on a server with
two 2.6-GHz Intel Xeon E5-2630 v2 CPUs and 64 GB of RAM. Each experiment uses
a single thread; the measured running time might be slightly distorted because of the
usual load jitter. For probabilistic LCFRS parsing we use two off-the-shelf systems:
If the induced grammar’s first component is equivalent to a FA, then we use the
OpenFST (Allauzen et al. 2007) framework with the Python bindings of Gorman (2016).
Otherwise, we utilize the LCFRS parser of Angelov and Ljunglöf (2014), which is part of
the runtime system of the Grammatical Framework (Ranta 2011).
7.1 Dependency Parsing
In our experiments on dependency parsing we use a corpus based on TIGER as provided
in the 2006 CoNLL shared task (Buchholz and Marsi 2006). The task specifies splits of
TIGER into a training set (39,216 sentences) and a test set (357 sentences). Each sentence
in the corpus consists of a sequence of tokens. A token has up to 10 fields, including
the sentence position, form, lemma, part-of-speech (POS) tag, sentence position of the
head, and dependency relation (DEPREL) to the head. In TIGER, 52 POS tags and 46

504

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

DEPRELs are used. We adopt the three evaluation metrics from the shared task, namely,
the percentages of tokens for which a parser correctly predicts the head (the unlabeled
attachment score or UAS), the DEPREL (the label accuracy or LA), or both head and
DEPREL (the labeled attachment score or LAS). Punctuation is removed from both
training and test sets, and is thereby ignored for the purposes of these metrics. For testing
we restrict ourselves to the 281 sentences of up to 20 (non-punctuation) tokens.
In our experiments, we use POS tags rather than lemmas or word forms. In order
to accommodate for dependency relations, node labels are of the form (a, b), where a is
the POS tag and b is the DEPREL to the head. Because input strings consist only of POS
tags, each terminal symbol in the LCFRS-part of a rule is projected to its first component.
Although our formal definition of hybrid rules only allows linking of pairs of terminal
symbols that are identical, the definition can be suitably generalized, without changing
the theory in any significant way. An example of a generalized hybrid rule, where a POS
tag NN is linked to a node label (NN, dobj), is:
1

1

[L{5}M(NN ) → hi, L{5}M(x1 , (NN, dobj) (x1 )) → hi]
Our experiments with grammar induction are controlled by three parameters, each
ranging over a number of values:

r
r

r

The naming scheme for nonterminals can be (i) strict labeling or (ii) child
labeling, as outlined in Section 6.8.
In both naming schemes, sequences of terminal labels from the hybrid tree
are composed into nonterminal labels. For each terminal, which is a CoNLL
token, we include only particular fields, namely, (i) POS and DEPREL,
(ii) POS, or (iii) DEPREL. We call this parameter argument label.
The considered methods to obtain recursive partitionings include (i) direct
extraction (see Algorithm 3), (ii) transformation to fanout k (see
Algorithm 4), (iii) right-branching, and (iv) left-branching.

Each choice of values for the parameters determines an experimental scenario. In
particular, direct extraction in combination with strict labeling achieves traditional LCFRS
parsing.
We compare our induction framework with rparse (Maier and Kallmeyer 2010),
which induces and trains unlexicalized, binarized, and Markovized LCFRS. As parser
for these LCFRS we choose the runtime system of the Grammatical Framework, because
it is faster than rparse’s built-in parser (for a comparison cf. Angelov and Ljunglöf 2014).
Additionally, we use MaltParser (Nivre, Hall, and Nilsson 2006) to compare our
approach with a well-established transition-based parsing architecture, which is not
state-of-the-art but allows us to disable features of lemmas and word forms, to match our
own implementation, which does not take lemmas or word forms as part of the input.
The stacklazy strategy (Nivre, Kuhlmann, and Hall 2009) with the LibLinear classifier is
used.
Experimental Results. Statistics on the induced hybrid grammars and parsing results are
listed in Table 2. For the purpose of measuring UAS, LAS, and LA, we take a default
dependency structure in the case of a parse failure; in this default structure, the head
of the i-th word is the i − 1-th word, and the DEPREL fields are left empty. Figure 19

505

Computational Linguistics

Volume 43, Number 3

Table 2
Experiments with dependency parsing (TIGER in CoNLL 2006 shared task): method of recursive
partitioning for extraction, argument label, number of nonterminals and rules, maximum and
average fanout, number of parse failures, unlabeled attachment score, labeled attachment score,
label accuracy, and parse time in seconds.
extraction

fmax

favg

fail

UAS

LAS

LA

time

61,923
60,399
49,448
48,844
191,341
196,125

4
1
2
3
1
1

1.06
1.00
1.18
1.19
1.00
1.00

68
9
11
11
60
56

68.0
85.8
85.7
85.6
68.9
70.3

59.5
79.7
79.7
79.7
60.3
61.9

63.2
85.5
85.4
85.3
65.0
66.7

97
94
103
108
27
28

799
6,060
2,396
2,121
47,661
49,203

43,439
28,880
20,592
20,100
123,367
125,406

4
1
2
3
1
1

1.10
1.00
1.38
1.44
1.00
1.00

23
4
4
4
23
26

78.2
83.2
83.8
83.4
77.9
78.5

59.7
65.3
65.4
65.2
59.8
60.2

67.2
73.2
73.1
73.1
68.1
67.5

113
70
86
88
53
51

527
4,344
1,739
40,239
37,535

33,844
21,613
15,184
99,113
92,390

4
1
2
1
1

1.10
1.00
1.35
1.00
1.00

1
1
1
1
1

79.5
78.0
78.7
77.2
78.1

72.4
70.6
70.9
69.1
69.8

82.7
81.4
81.6
80.7
80.9

251
172
263
94
85

arg. lab.

nont.

rules

direct
k=1
k=2
k=3
r-branch
l-branch

POS+DEPREL
POS+DEPREL
POS+DEPREL
POS+DEPREL
POS+DEPREL
POS+DEPREL

4,043
17,333
10,777
10,381
92,624
96,980

direct
k=1
k=2
k=3
r-branch
l-branch

POS
POS
POS
POS
POS
POS

direct
k=1
k=2
r-branch
l-branch

DEPREL
DEPREL
DEPREL
DEPREL
DEPREL

child labeling

strict labeling
direct
k=1
k=2
k=3
r-branch
l-branch

POS+DEPREL
POS+DEPREL
POS+DEPREL
POS+DEPREL
POS+DEPREL
POS+DEPREL

48,404
103,425
92,395
91,412
251,536
264,190

106,284
162,124
150,013
149,106
338,294
349,299

4
1
2
3
1
1

1.01
1.00
1.08
1.08
1.00
1.00

68
57
55
55
141
137

68.0
72.2
72.0
72.0
44.6
45.3

59.5
64.2
64.4
64.4
31.4
32.6

63.2
68.3
68.6
68.6
32.7
34.2

122
185
266
240
54
53

direct
k=1
k=2
k=3
r-branch
l-branch

POS
POS
POS
POS
POS
POS

29,165
62,769
54,082
53,186
181,432
190,890

80,695
115,363
104,390
103,503
277,201
286,273

4
1
2
3
1
1

1.00
1.00
1.09
1.11
1.00
1.00

23
18
18
18
98
108

77.6
78.7
79.5
79.6
55.1
52.2

59.6
60.9
61.3
61.4
36.4
33.9

67.5
69.1
69.4
69.5
40.8
37.7

120
201
237
231
88
87

direct
k=1
k=2
r-branch
l-branch

DEPREL
DEPREL
DEPREL
DEPREL
DEPREL

17,047
37,333
31,956
126,841
124,722

53,342
71,423
63,487
197,261
192,922

4
1
2
1
1

1.00
1.00
1.08
1.00
1.00

3
1
2
2
2

82.4
83.2
83.0
80.8
81.2

76.5
78.0
77.5
74.4
74.8

84.6
85.8
85.5
83.1
83.5

178
188
231
101
96

rparse (v = 1, h = 5)
46,799
MaltParser, unlexicalized, stacklazy

72,962

5

1.07

2
0

85.3
88.2

79.0
83.7

86.4
88.7

228
2

shows the distributions of the fanout of nonterminals in the LCFRS and the numbers of
arguments in the sDCP, depending on the recursive partitioning strategy if we fix child
labeling with POS+DEPREL as argument labels. In the following we discuss trends that
can be observed in these data if we change the value of one parameter while keeping
others fixed.

506

Gebhardt, Nederhof, and Vogler

1

2

3

fanout

4

100%

100%

80%

80%

60%

60%

40%

40%

20%

20%

0%

0%
1

2

3

4

5

6

7

8

nonterminals

direct
k=1
k=2
k=3
k=4
r-branch
l-branch

Hybrid Grammars

9 10

number of sDCP arguments

Figure 19
The percentage of nonterminals with a particular fanout and number of sDCP arguments
depending on the recursive partitioning strategy. All grammars are induced from TIGER using the
child labeling strategy with POS and DEPREL as argument labels.

Naming Scheme. As expected, child labeling leads to significantly fewer distinct nonterminals than strict labeling, by a factor of between 2.5 and 37, depending on the other
parameter values. This makes the tree language less refined, and one may expect the
scores therefore to be generally lower. However, in many cases where strict labeling
suffers from a higher proportion of parse failures (so that the parser must fall back on
the default structure), it is child labeling that has the higher scores.
Argument Labels. Including only POS tags in nonterminal labels generally leads to high
UAS but low LA. By including DEPRELs but not POS tags, the LA and LAS are higher in
all cases. For child labeling, this is at the expense of a lower UAS, in all cases except one.
For strict labeling, UAS is higher in all cases. There are also fewer parse failures, which
may be because the number of DEPRELs is smaller than the number of POS tags.
With the combination of POS tags and DEPRELs, the tree language can be most
accurately described, and we see that this achieves some of the highest UAS and LAS in
the case of child labeling. However, the scores can be low in the presence of many parse
failures, due to the fall-back on the default structure. This holds in particular in the case
of strict labeling.
Recursive Partitionings. Concerning the choice of the method to obtain recursive partitionings, the baseline is direct extraction, which produces an unrestricted LCFRS in the first
component. For instance, for child labeling and POS and DEPREL as argument labels, the
induced LCFRS has fanout 4 and about 88% of the rules have three or more nonterminals
on the right-hand side. In total there are 4,043 nonterminals, the majority of which have
fanout 1. Reduction of the fanout to 1 ≤ k ≤ 3 leads to a binarized grammar with smaller
fanout as desired but the number of nonterminals is quadrupled. By transforming a
recursive partitioning with parameter k ≥ 2, the average fanout favg of nonterminals
may in fact increase, which is somewhat counter-intuitive. Whereas the distribution
of nonterminals with fanout 1, 2, 3 is 94.8%, 4.2%, 0.9% in the case of direct extraction,

507

Computational Linguistics

Volume 43, Number 3

this changes to distribution 83.4%, 14.2%, 2.5% for the transformation with k = 2. We
suspect the increase is due to the high fanout of newly introduced nodes (see line 8 of
Algorithm 4).
We can further see in Figure 19 that the number of arguments in the sDCP increases
signficantly once the fanout is restricted to k = 1. The binarization involved in the process
of reducing the fanout to some value of k seems to improve the ability of the grammar to
generalize over the training data, as here both the number of parse failures drops and
the scores increase. The exact choice of k has little impact on the scores, however.
The measured parse times in most cases increase if higher values of k are chosen.
In some cases, however, the parse times are lower for direct extraction. This may be
explained by the higher average fanout and differences in the sizes of the grammars.
The left-branching and right-branching recursive partitionings lead to many specialized nonterminal symbols (and rules). In comparison with the partitioning strategies
discussed earlier, we observe that a nonterminal can have up to 10 sDCP arguments,
the average lying between 3 and 4. The scores are often worse and there tend to be
more parse failures. However, in the case of child labeling with DEPREL as argument
label, the scores are very similar. Left-branching seems to lead to slightly higher scores
than right-branching recursive partitioning, except for POS as argument label. With
left-branching and right-branching recursive partitionings, parsing tends to be faster
than with the other recursive partitionings. However, in many cases we do not observe
the predicted asymptotic differences, which may be due to larger grammar sizes.
Overall, child labeling with POS+DEPREL and k = 1 and strict labeling with
DEPREL and k = 1 turned out to be the best choices for maximizing UAS/LAS and
LA, respectively. The former scenario slightly outperforms rparse with respect to UAS
and LAS and parse time whereas rparse obtains better LA. Still, MaltParser outperforms
these experimental scenarios with respect to both the obtained scores and the measured
parse times. Our restriction to sentence length 20, which we mentioned earlier, was
motivated by the excessive computational costs for instances with high (average) fanout.
The most suitable choices for naming scheme, argument labeling, and recursive
partitioning may differ between languages and between annotation schemes. For
instance, for the NEGRA (Skut et al. 1997) benchmark used by Maier and Kallmeyer
(2010), we obtain the results in Table 3, which suggest the combination of child labeling,
DEPREL, and k = 2 is the most suitable choice if LAS is the target score. It appears that
scenarios with POS+DEPREL give lower scores than DEPREL, mainly because of the
many parse failures, despite the fact that such argument labeling can be expected to
lead to more refined tree languages. For this reason, we also consider a cascade of three
scenarios with child labeling, k = 1, and argument labels set to POS+DEPREL, POS, or
DEPREL, respectively, where in the case of parse failure we fall back to the next scenario.
This cascade achieves better scores than any individual experimental scenario and the
additional parse time with respect to POS+DEPREL alone is small. Both the single best
scenario and the cascade perform better than the baseline LCFRS (rparse simple) induced
with the algorithm by Kuhlmann and Satta (2009) and the LCFRS that is obtained from
the baseline by binarization, vertical Markovization v = 1, and horizontal Markovization
h = 3. Again, hybrid grammars fall short of MaltParser. We do not include results for
NEGRA with the strict labeling strategy, because the numbers of parse failures are too
high and, consequently, accuracies are too low to be of interest.
Note that the hybrid grammar obtained with child labeling, DEPREL, and direct
extraction should, in principle, be similar to the baseline LCFRS. Indeed, both grammars
have the same fanout and similar numbers of rules. The differences in size can be
explained by the separation of terminal generating and structural rules during hybrid

508

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

UASp

LASp

Table 3
Experiments with dependency parsing (NEGRA). From the sentences with length ≤ 25, the first
14,858 make up the training corpus and the remaining 1,651 the test corpus. Additionally to the
columns in Table 2, we present unlabeled and labeled attachment scores that include punctuation
(UASp and LASp, respectively).
UAS

direct
k=1
k=2
r-branch
l-branch

P+D
P+D
P+D
P+D
P+D

4,739 27,042
13,178 35,071
11,156 32,231
42,577 79,648
40,100 75,321

7
1
2
1
1

1.10
1.00
1.17
1.00
1.00

693
202
195
775
768

51.7
75.9
76.5
45.5
45.8

40.7
68.7
69.6
33.1
33.4

52.2
77.0
77.7
45.7
46.0

40.8
69.1
70.1
32.8
33.2

42.6
73.3
74.2
34.7
35.0

253
288
355
49
45

direct
k=1
k=2
r-branch
l-branch

POS
POS
POS
POS
POS

675 19,276
3,464 15,826
2,099 13,347
19,804 51,733
17,240 45,883

7
1
2
1
1

1.24 303
1.00
30
1.40
35
1.00 372
1.00 342

68.7
81.7
81.6
62.7
63.7

51.5
65.5
65.2
46.4
47.4

69.3
82.5
82.4
62.7
63.9

50.0
63.5
63.3
44.7
45.6

55.4
70.6
70.5
50.6
51.4

300
244
410
222
197

direct
k=1
k=2
k=3
r-branch
l-branch

DEP
DEP
DEP
DEP
DEP
DEP

2,505
8,059
6,651
6,438
27,653
25,699

7
1
2
3
1
1

1.13
1.00
1.20
1.25
1.00
1.00

3
1
1
1
2
1

78.5
78.5
78.7
78.6
76.0
75.8

72.2
71.7
72.1
72.0
68.4
68.4

78.9
79.5
79.8
79.5
76.3
76.2

71.6
71.7
72.0
71.9
67.5
67.6

78.6
484
79.0
608
79.2
971
79.1 1,013
76.1
216
76.1
198

1

83.2

76.2

84.3

76.1

81.6

325

- 79.0 71.8
56 77.1 70.6
13 78.4 72.2
0 85.0 80.2

77.3
78.5
85.6

70.0 76.2
71.4 79.0
80.0 85.0

350
778
24

arg.
lab.

extraction

nont.

rules fmax

favg

fail

LAS

LA

time

child labeling

19,511
22,613
20,314
19,962
54,360
50,418

cascade: child labeling, k = 1, P+D/POS/DEP
LCFRS (Maier and Kallmeyer 2010)
rparse simple
920 18,587
rparse (v = 1, h = 3) 40,141 61,450
MaltParser, unlexicalized, stacklazy

7
7

1.37
1.10

grammar induction, which is not present in the induction algorithm by Kuhlmann and
Satta (2009). This separation also leads to different generalization over the training data,
as the higher accuracy and the lower numbers of parse failures for the hybrid grammar
indicate.
One possible refinement of this result is to choose different argument labels for
inherited and synthesized arguments. One may also use form or lemma next to, or
instead of, POS tags and DEPRELs, possibly in combination with smoothing techniques
to handle unknown words. Another subject for future investigation is the use of splitting
and merging (Petrov et al. 2006) to determine parts of nonterminal names. New recursive
partitioning strategies may be developed, and one could consider blending grammars
that were induced using different recursive partitioning strategies.
7.2 Constituent Parsing
The experiments for constituent parsing are carried out as in Nederhof and Vogler (2014)
but on a larger portion of the TIGER corpus: We now use the first 40,000 sentences for
training (omitting 10 where a single tree does not span the entire sentence), and from
the remaining 10,474 sentences we remove the ones with length greater than 20, leaving
7,597 sentences for testing. The results are displayed in Table 4 and allow for similar
conclusions as in Nederhof and Vogler (2014). Note that for direct extraction both labeling

509

Computational Linguistics

Volume 43, Number 3

Table 4
Experiments for constituent parsing (TIGER). Number of nonterminals, rules, and parse failures,
recall, precision, F-measure, average number of gaps per constituent, and parse time in seconds.
nont.

rules

fail

R

P

F1

# gaps

time

104
26,936
19,387
18,685
164,842
284,816

31,656
62,221
51,414
50,678
248,063
348,536

10
11
9
9
658
3,662

77.5
77.1
77.5
77.5
61.2
37.7

77.7
77.1
77.8
77.8
58.2
34.8

76.9
76.4
76.9
76.9
59.1
35.7

0.0139
0.0136
0.0136
0.0135
0.0135
0.0131

2,098
2,514
2,892
2,886
1,341
2,143

2,117
473
176
27,222
87,171

13,877
8,078
7,352
83,035
162,645

1
1
1
36
137

75.3
75.6
75.7
75.0
74.5

74.9
75.4
75.4
74.4
73.9

74.5
74.9
74.9
74.1
73.6

0.0140
0.0144
0.0144
0.0148
0.0146

1,196
1,576
1,667
502
702

strict labeling
direct
k=1
k=2
k=3
r-branch
l-branch
child labeling
k=1
k=2
k=3
r-branch
l-branch

strategies yield the same grammar; thus, only one entry is shown. Unsurprisingly, the
larger training set leads to smaller proportions of parse failures and to improvements
of F-measure. Another consequence is that the more fine-grained strict labeling now
outperforms child labeling, except in the case of right-branching and left-branching,
where the numbers of parse failures push the F-measure down.
Note that the average numbers of gaps per constituent are very similar for the
different recursive partitionings. One may observe once more that the parse times of
right-branching and left-branching recursive partitionings are higher than one might
expect from the asymptotic time complexities. This is again due to the considerable sizes
of the grammars.
8. Related Work
Two kinds of discriminative models of non-projective dependency parsing have been
intensively studied. One is based on an algorithm for finding the maximum spanning
tree (MST) of a weighted directed graph, where the vertices are the words of a sentence,
and each edge represents a potential dependency relation (McDonald et al. 2005). In
principle, any non-projective structure can be obtained, depending on the weights of
the edges. A disadvantage of MST dependency parsing is that it is difficult to put any
constraints on the desirable structures beyond the local constraints encoded in the edge
weights (McDonald and Pereira 2006).
The second kind of model involves stack-based transition systems, with an added
transition that swaps stack elements. In particular, Nivre (2009) introduced a deterministic system that uses a classifier to determine the next transition to be applied. The
worst-case time complexity is quadratic, and the expected complexity is linear. The
classifier relies on features that look at neighboring words in the sentence, as well as at
vertical and horizontal context in the syntactic tree. Advances in learning the relevant
features are due to Chen and Manning (2014).
In this article we have assumed a generative model of hybrid grammars, which
differs from deterministic, stack-based models in at least two ways, one of which is
superficial whereas the other is more fundamental. The superficial difference is the

510

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

presence of nonterminals in hybrid grammars. These, however, fulfill a role that is
comparable to that of sets of features used by classifiers. We conjecture that machine
learning techniques could even be introduced to create more refined nonterminals for
hybrid grammars. The more fundamental difference lies in the determinism of the
discussed stack-based models, which is difficult to realize for hybrid grammars, except
perhaps in the case of left-branching and right-branching recursive partitionings. Without
determinism, the time complexity grows with the fanout that we allow for the left
components of hybrid grammars. What we get in return for the higher running time are
more powerful models for parsing the input.
As in the case of MST dependency parsing, the discussed stack-based transition
systems can in principle produce any non-projective structure. The non-projectivity
allowed by hybrid grammars is determined by the hybrid rules, which in turn are
determined by non-projectivity that occurs in the training data. This means that there is
no restriction per se on non-projectivity in structures produced by a parser for test data,
provided the training data contains an adequate amount of non-projectivity. This even
holds if we restrict the fanout of the first component, although we may then need more
training data to obtain the same coverage and accuracy.
Many established algorithms for constituent parsing rely on generative models and
grammar induction (Collins 1997; Charniak 2000; Klein and Manning 2003; Petrov et al.
2006). Most of these are unable to produce discontinuous structures. A notable exception
is Maier and Søgaard (2008), where the induced grammar is a LCFRS. Such a grammar
can be seen as a special case of a LCFRS/sDCP hybrid grammar, with the restriction that
each nonterminal has a single synthesized argument. This restriction limits the power of
hybrid grammars. In particular, discontinuous structures can now only be produced if
the fanout is strictly greater than 1, which also implies the time complexity is more than
cubic.
Generative models proposed for dependency parsing have often been limited to
projective structures, based on either context-free grammars (Eisner 1996; Klein and
Manning 2004) or tree substitution grammars (Blunsom and Cohn 2010). Exceptions
are recent models based on LCFRS (Maier and Kallmeyer 2010; Kuhlmann 2013). As
in the case of constituent parsing, these can be seen as restricted LCFRS/sDCP hybrid
grammars.
A related approach is from Satta and Kuhlmann (2013). Although it does not use an
explicit grammar, there is a clear link to mildly context-sensitive grammar formalisms, in
particular lexicalized TAG, following from the work of Bodirsky, Kuhlmann, and Möhl
(2005).
The flexibility of generative models has been demonstrated by a large body of literature. Applications and extensions of generative models include syntax-based machine
translation (Charniak, Knight, and Yamada 2003), discriminative reranking (Collins 2000),
and involvement of discriminative training criteria (Henderson 2004). It is very likely
that these apply to hybrid grammars as well. Further discussion is outside the scope of
this article.
Appendix A. Single-Synthesized sDCPs Have the Same s-term Generating Power
as sCFTGs
The proof of Theorem 1 is the following.
Proof. Let G be a single-synthesized sDCP. We construct a sCFTG G0 such that [G] = [G0 ].
For each nonterminal A from G, there will be one nonterminal A0 in G0 , with rk(A0 ) =
i-rk(A).

511

Computational Linguistics

(0)

Volume 43, Number 3

(1)

(n)

Let A0 (x1,k0 , s(0) ) → hA1 (s1,k1 , x(1) ), . . . , An (s1,kn , x(n) )i be a rule of G, with km = i-rk(Am )
(0)

for m ∈ [n]0 . Assume without loss of generality that x1,k0 = x1,k0 . Then G0 will contain the
rule A00 (x1,k0 ) → rhs(s(0) ), where rhs is defined by:
rhs(ht1,k i ) = rhs(t1 ) · . . . · rhs(tk )
rhs(δ(s1,k )) = hδ(rhs(s1 ), . . . , rhs(sk ))i
(0)

rhs(x) = hxi, if x is xi
(m)

(i ∈ [k0 ])
(m)

rhs(x) = A0m (rhs(s1 ), . . . , rhs(skm )), if x is x(m) (m ∈ [n])
It is not difficult to prove that:

hA(s1,k , s)i ⇒∗G hi if and only if hA0 (s1,k )i ⇒∗G0 s
for every nonterminal A of G and s-terms s, s1 , . . . , sk . Hence [G] = [G0 ].
There is an inverse transformation from a sCFTG to a sDCP with s-rk(A) = 1 for
each A. This is as straightforward as the transformation above. In fact, one can think of
sCFTGs and sDCPs with s-rank restricted to 1 as syntactic variants of one another.
A more extensive treatment of a very closely related result is from Mönnich (2010),
who refers to a special form of attributed tree transducers in place of sDCPs. This result for
tree languages was inspired by an earlier result by Duske et al. (1977) for string languages,
involving (non-simple) macro grammars (with IO derivation) and simple-L-attributed
grammars. For arbitrary s-rank, a related result is that attributed tree transductions are
equivalent to attribute-like macro tree transducers, as shown by Fülöp and Vogler (1999).

Appendix B. The Class of s-term Languages Induced by sDCP Is Strictly Larger than
that Induced by sCFTG
By Theorem 1, sCFTG and single-synthesized sDCP have the same s-term generating
power. Thus it suffices to show that the full class of sDCP is strictly more powerful than
single-synthesized sDCP. For this we represent the only-synthesized attribute grammar
of Engelfriet and Filè (1981, page 298) as sDCP G as follows:
S(A(x1 x2 )) → A(x1 , x2 )
A(B(x1 x3 ), B0 (x2 x4 )) → A(x1 , x2 ) A(x3 , x4 )
A(B(ε ), B0 (ε )) → ε
where s-rk(S) = 1, s-rk(A) = 2, and i-rk(A) = 0. It should be clear that the induced s-term
language [G] contains trees of the form A(s, s0 ) where s and s0 are s-terms over {B} and
{B0 }, respectively, and pos(s) = pos(s0 ) and s0 is obtained from s by replacing each B
by B0 .
In Section 5 of Engelfriet and Filè (1981) it was proved that [G], viewed as language
of binary trees, cannot be induced by 1S-AG, that is, attribute grammars with one
synthesized attribute (and any number of inherited attributes). Although singlesynthesized sDCP can generate s-terms (and not only trees as 1S-AG can), it is rather

512

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

obvious to see that this extra power does not help to induce [G]. Thus we conclude that
there is no single-synthesized sDCP that induces [G].
Appendix C. sDCP Have the Same String Generating Power as LCFRS
The proof of Theorem 2 is the following.
Proof. We show that for each sDCP G1 there is a LCFRS G2 such that [G2 ] = pre([G1 ]),
where pre was extended from s-terms to sets of s-terms in the obvious way. Our
construction first produces sDCP G01 from G1 by replacing every s-term s in every rule of
G1 by pre(s). It is not difficult to see that [G01 ] = pre([G1 ]).
Next, for every nonterminal A in G01 , with i-rk(A) = k0 and s-rk(A) = k, we introduce
nonterminals of the form A(g) , where g is a mapping from [k] to sequences of numbers in
[k0 ], such that each j ∈ [k0 ] occurs precisely once in g(1) · . . . · g(k). The intuition is that if
g(i) = hj1 , . . . , jpi i, then a value appearing as the jq -th inherited argument of A reappears
as part of the i-th synthesized argument, and it is the q-th inherited argument to do so.
(This concept is similar to the argument selector in Courcelle and Franchi-Zannettacci
[1982, page 175].) For each A, only those functions g are considered that are consistent
with at least one subderivation of G01 .
(g )
We will show that whereas replacing a nonterminal Am by Am m , as m-th member
(m)
in the right-hand side of a rule of the form of Equation (3), a variable xi appearing as
(m,p(m) )

(m,0)

the i-th synthesized argument is split up into several new variables xi
, . . . , xi i .
These variables are drawn from X so as not to clash with variables used before. The
(m)
pi terms of the inherited arguments whose indices are listed by gm (i) will be shifted
(m)
to the left-hand side of a new rule to be constructed, interspersed with the pi + 1 new
variables. This shifting of terms may happen along dependencies between inherited
and synthesized arguments of other members in the right-hand side. (This shifting is
again very similar to the one for obtaining rules for an IO-macro grammar from a simple
L-attributed grammar (Duske et al. 1977, Def.6.1)).
More precisely, we construct a new grammar G001 from G01 by iteratively adding more
elements to its set of nonterminals and to its set of rules, until no more new nonterminals
(0)
and rules can be found. In each iteration, we consider a rule from G01 of the form A0 (x1,k0 ,
0
(0)
(1)
(1)
(n)
(n)
s1,k0 ) → hA1 (s1,k0 , x1,k1 ), . . . , An (s1,k0 , x1,kn )i, and a choice of functions g1 , . . . , gn such that
1

n

(g )

the nonterminals Am m (m ∈ [n]) were found before. We define a function “exp” that
expands terms and s-terms as follows:
exp(ht1 , . . . , tk i ) = exp(t1 ) · . . . · exp(tk )
exp(δ(hi )) = hδ(hi )i
(0)

exp(x) = hxi, if x is xi
(m,0)

exp(x) = hxi

(i ∈ [k00 ])
(m,pi(m) )

(m,1)
i · exp(sj(m)
) · hxi
i · . . . · exp(sj(m)
) · hxi
1
(m)

i

p
i

(m)

if x is xi

(m ∈ [n], i ∈ [km ]) and gm (i) = hj1 , . . . , jp(m) i
i

Note that, despite the recursion, “exp” is well-defined due to our assumption that sDCPs
are free of cycles.

513

Computational Linguistics

Volume 43, Number 3

(0)

For i ∈ [k0 ], define g0 (i) = hj1 , · · · , jpi i, where exp(si ) is of the form:
(i)

(0)

(i)

(0)

(i)

r0 · hxj1 i · r1 · . . . · hxjp i · rpi
i

(0)

(i)

and no variables from among x1,k0 occur in any rj (j ∈ [pi ]0 ).
0
The new grammar G001 will now contain the rule:
(g )

(1)

(k )

(g )

(g )

(1)

(n)

A0 0 (r0,p1 , . . . , r0,p0 k ) → hA1 1 (y1,k1 ), . . . , An n (y1,kn )i
0

(m)

(m,p(m) )

(m,0)

where each yi is xi
, . . . , xi i , for m ∈ [n] and i ∈ [km ]. This also defines the
(g0 )
nonterminal A0 to be added to G001 if it does not already exist.
In order to clarify the semantic relationship between derivations of G01 and G001 we allow the sentential forms in derivations of a sDCP to contain variables; they can be viewed
as extra nullary symbols. Moreover, each derivation of the form hA(x1,k00 , s1,k0 )i ⇒∗G0 hi
1
induces in an obvious way an argument selector function g. Let A be a nonterminal with
k00 inherited arguments and k0 synthesized arguments. Let s1,k0 be s-terms in TΣ (Xk00 ) such
that each xi ∈ Xk00 occurs exactly once in s1,k0 . For each j ∈ [k0 ] we let:
(j)

(j)

(j)

sj = r0 · hxj1 i · r1 · . . . · hxjp i · rpj
j

(j)

(j)

such that none of r0 , . . . , rpj contain any variables. We define the argument selector
mapping g by g(j) = hj1 , . . . , jpj i for each j ∈ [k0 ].
Then the following two statements are equivalent:
1.

hA(x1,k00 , s1,k0 )i ⇒∗G0 hi and g is the argument selector function of this
1
derivation.

2.

(1)
(k )
hA(g) (r0,p
, . . . , r0,p0 k )i ⇒∗G00 hi.
1
0

1

The grammar G001 constructed here has no inherited arguments and is almost the
required LCFRS G2 . To precisely follow our definitions, what remains is to consistently
rename the variables in each rule to obtain the set Xm , some m. Furthermore, the symbols
from Σ now need to be explicitly assigned rank 0.
For the converse direction of the theorem consider LCFRS G. We construct sDCP G0
by taking the same nonterminals as those of G, with the same ranks. Each argument is
synthesized. To obtain the rules of G0 , we replace each term a() by the term a(hi ).
Example 23
If G1 contains the rules:
C(x1 , x2 , σ(x2 α(x1 ))) → ε
A(x1 , x2 , α(x1 x3 )) → B(β(x2 ), x4 ) C(γ, x4 , x3 )
514

Gebhardt, Nederhof, and Vogler

Hybrid Grammars

then G01 has the rules:
C(x1 , x2 , σ x2 α x1 ) → ε
A(x1 , x2 , α x1 x3 ) → B(β x2 , x4 ) C(γ, x4 , x3 )
where i-rk(A) = 2, i-rk(B) = 1, and i-rk(C) = 2 for G1 and G01 . For the first rule we have
exp(σ x2 α x1 ) = σ x2 α x1 and we obtain the function g(1) = h2, 1i, because x2 occurs
before x1 . This leads to the new rule:
C(g) (σ, α, ε ) → ε
For the second rule in G01 , assume g2 = g with g the function we found for the first
rule. Further assume we previously found nonterminal B(g1 ) with g1 (1) = h1i, which is
in fact the only allowable function for B. Then:
exp(αx1 x3 )

= αx1 exp(x3 )
= αx1 x3(0) exp(x4 )x3(1) exp(γ )x3(2)
= αx1 x3(0) x4(0) exp(βx2 )x4(1) x3(1) γx3(2)
= αx1 x3(0) x4(0) βx2 x4(1) x3(1) γx3(2)
Because x1 occurs before x2 we have g0 (1) = h1, 2i and we derive the rule:
(0) (0)

(1) (1)

(2)

(0)

(1)

(0)

(1)

(2)

A(g0 ) (α, x3 x4 β, x4 x3 γx3 ) → B(g1 ) (x4 , x4 ) C(g2 ) (x3 , x3 , x3 )
Example 24
By the same construction, the sDCP from Example 8 is transformed into the following
LCFRS (after renaming of variables, and simplifying nonterminal names):
S0 (x2 x1 x3 ) → A0 (x1 ) B0 (x2 , x3 )
A (a A x1 b) → A0 (x1 )
A0 ( ε ) → ε
0

Acknowledgments
We are grateful to the reviewers for their
constructive criticism and encouragement.
We also thank Markus Teichmann for
helpful discussions. The third author was
financially supported by the Deutsche
Forschungsgemeinschaft by project DFG VO
1011/8-1.

References
Allauzen, Cyril, Michael Riley, Johan
Schalkwyk, Wojciech Skut, and Mehryar
Mohri. 2007. Openfst: A general and
efficient weighted finite-state transducer

B0 (c B x1 , x2 d) → B0 (x1 , x2 )
B0 (ε, ε ) → ε
library. In Implementation and Application of
Automata: 12th International Conference,
pages 11–23, Prague.
Angelov, Krasimir and Peter Ljunglöf. 2014.
Fast statistical parsing with parallel
multiple context-free grammars. In
Proceedings of the 14th Conference of the
European Chapter of the Association for
Computational Linguistics, pages 368–376,
Gothenburg.
Becker, T., A. K. Joshi, and O. Rambow. 1991.
Long-distance scrambling and Tree
Adjoining Grammars. In Fifth Conference of
the European Chapter of the Association for
Computational Linguistics, Proceedings of the
Conference, pages 21–26, Berlin.

515

Computational Linguistics

Blunsom, P. and T. Cohn. 2010. Unsupervised
induction of tree substitution grammars for
dependency parsing. In Conference on
Empirical Methods in Natural Language
Processing, Proceedings of the Conference,
pages 1204–1213, Massachusetts.
Bochmann, G. V. 1976. Semantic evaluation
from left to right. Communications of the
ACM, 19(2):55–62.
Bodirsky, M., M. Kuhlmann, and M. Möhl.
2005. Well-nested drawings as models of
syntactic structure. In Proceedings of the 10th
Conference on Formal Grammar and 9th
Meeting on Mathematics of Language,
pages 195–203, Edinburgh.
Böhmová, A., J. Hajič, E. Hajičová, and
B. Hladká. 2000. The Prague dependency
treebank: A tree-level annotation scenario.
In A. Abeillé, editor, Treebanks: Building and
Using Syntactically Annotated Corpora,
Kluwer, Dordrecht, pages 103–127.
Boyd, A. 2007. Discontinuity revisited: An
improved conversion to context-free
representations. In Proceedings of the
Linguistic Annotation Workshop, at ACL 2007,
pages 41–44, Prague.
Brainerd, W. S. 1969. Tree generating regular
systems. Information and Control, 14:217–231.
Brants, S., S. Dipper, P. Eisenberg, S.
Hansen-Schirra, E. König, W. Lezius, C.
Rohrer, G. Smith, and H. Uszkoreit. 2004.
TIGER: Linguistic interpretation of a
German corpus. Research on Language and
Computation, 2:597–620.
Bresnan, J., R. M. Kaplan, S. Peters, and A.
Zaenen. 1982. Cross-serial dependencies in
Dutch. Linguistic Inquiry, 13(4):613–635.
Buchholz, S. and E. Marsi. 2006. CoNLL-X
shared task on multilingual dependency
parsing. In Proceedings of the Tenth
Conference on Natural Language Learning,
pages 149–164, New York.
Campbell, R. 2004. Using linguistic principles
to recover empty categories. In 42nd Annual
Meeting of the Association for Computational
Linguistics, Proceedings of the Conference,
pages 645–652, Barcelona.
Charniak, E. 1996. Tree-bank grammars. In
AAAI 96 Proceedings, pages 1031–1036,
Portland, OR.
Charniak, E. 2000. A maximumentropy-inspired parser. In 6th Applied
Natural Language Processing Conference and
1st Meeting of the North American Chapter of
the Association for Computational Linguistics,
pages 132–139 (Section 2), Seattle, WA.
Charniak, E., K. Knight, and K. Yamada. 2003.
Syntax-based language models for
statistical machine translation. In
Proceedings of the Ninth Machine Translation

516

Volume 43, Number 3

Summit, pages 40–46, New Orleans,
LA.
Chen, D. and C. D. Manning. 2014. A fast
and accurate dependency parser using
neural networks. In Conference on Empirical
Methods in Natural Language Processing,
Proceedings of the Conference, pages 740–750,
Doha.
Chomsky, N. 1981. Lectures on Government and
Binding, volume 9 of Studies in Generative
Grammar. Foris Publications.
Collins, M. 1997. Three generative, lexicalised
models for statistical parsing. In 35th
Annual Meeting of the Association for
Computational Linguistics, Proceedings of the
Conference, pages 16–23, Madrid.
Collins, M. 2000. Discriminative reranking for
natural language parsing. In Proceedings of
the Seventeenth International Conference on
Machine Learning, pages 175–182,
Stanford, CA.
Courcelle, B. and P. Franchi-Zannettacci. 1982.
Attribute grammars and recursive program
schemes. Theoretical Computer Science,
17:163–191.
van Cranenburgh, A. 2012. Efficient parsing
with linear context-free rewriting systems.
In Proceedings of the 13th Conference of the
European Chapter of the Association for
Computational Linguistics, pages 460–470,
Avignon.
Daniels, M. and W. D. Meurers. 2002.
Improving the efficiency of parsing
with discontinuous constituents. In
Proceedings of NLULP’02: The 7th
International Workshop on Natural Language
Understanding and Logic Programming,
pages 49–68, Copenhagen.
Daniels, M. W. and W. D. Meurers. 2004.
A grammar formalism and parser for
linearization-based HPSG. In the 20th
International Conference on Computational
Linguistics, volume 1, pages 169–175,
Geneva.
Deransart, P., M. Jourdan, and B. Lorho.
1988. Attribute Grammars: Definitions,
Systems and Bibliography, volume 323 of
Lecture Notes in Computer Science.
Springer-Verlag.
Deransart, P. and J. Małuszynski. 1985.
Relating logic programs and attribute
grammars. Journal of Logic Programming,
2:119–155.
Duske, J., R. Parchmann, M. Sedello, and
J. Specht. 1977. IO-macrolanguages and
attributed translations. Information and
Control, 35:87–105.
Eisner, J. 1996. Three new probabilistic models
for dependency parsing: An exploration.
In the 16th International Conference on

Gebhardt, Nederhof, and Vogler

Computational Linguistics, volume 1,
pages 340–345, Copenhagen.
Engelfriet, J. and G. Filè. 1981. The formal
power of one-visit attribute grammars.
Acta Informatica, 16:275–302.
Engelfriet, J. and E. M. Schmidt. 1977. IO and
OI. I. Journal of Computer and System
Sciences, 15:328–353.
Engelfriet, J. and E. M. Schmidt. 1978. IO and
OI. II. Journal of Computer and System
Sciences, 16:67–99.
Engelfriet, J. and H. Vogler. 1998. The
equivalence of bottom-up and top-down
tree-to-graph transducers. Journal of
Computer and System Sciences, 56:332–356.
Evang, K. and L. Kallmeyer. 2011. PLCFRS
parsing of English discontinuous
constituents. In Proceedings of the 12th
International Conference on Parsing
Technologies, pages 104–116, Dublin.
Fischer, M. J. 1968. Grammars with macro-like
productions. In IEEE Conference Record of
9th Annual Symposium on Switching and
Automata Theory, pages 131–142,
Schenectady, NY.
Fouvry, F. and D. Meurers. 2000. Towards a
platform for linearization grammars. In
Proceedings of the Workshop on Linguistic
Theory and Grammar Implementation, at
ESSLLI-2000, pages 153–168,
Birmingham.
Fülöp, Z. and H. Vogler. 1999. A
characterization of attributed tree
transformations by a subclass of macro tree
transducers. Theoretical Computer Science,
32:649–676.
Gabbard, R., S. Kulick, and M. Marcus. 2006.
Fully parsing the Penn Treebank. In
Proceedings of the Human Language
Technology Conference of the NAACL, Main
Conference, pages 184–191, New York.
Gebhardt, K. and J. Osterholzer. 2015. A direct
link between tree-adjoining and
context-free tree grammars. In Proceedings of
the 12th International Conference on
Finite-State Methods and Natural Language
Processing (FSMNLP 2015), Düsseldorf.
Gécseg, F. and M. Steinby. 1997. Tree
languages. In G. Rozenberg and A.
Salomaa, editors, Handbook of Formal
Languages, Vol. 3. Springer, Berlin, chapter 1,
pages 1–68.
Giegerich, R. 1988. Composition and
evaluation of attribute coupled grammars.
Acta Informatica, 25:355–423.
Gómez-Rodríguez, C., M. Kuhlmann, and
G. Satta. 2010. Efficient parsing of
well-nested linear context-free rewriting
systems. In Human Language Technologies:
The 2010 Annual Conference of the North

Hybrid Grammars

American Chapter of the Association for
Computational Linguistics, Proceedings of the
Main Conference, pages 276–284, Los
Angeles, CA.
Gómez-Rodríguez, C., M. Kuhlmann, G. Satta,
and D. Weir. 2009. Optimal reduction of
rule length in linear context-free rewriting
systems. In Proceedings of Human Language
Technologies: The 2009 Annual Conference of
the North American Chapter of the Association
for Computational Linguistics, pages 539–547,
Boulder, CO.
Gómez-Rodríguez, C. and G. Satta. 2009. An
optimal-time binarization algorithm for
linear context-free rewriting systems with
fan-out two. In Proceedings of the Joint
Conference of the 47th Annual Meeting of the
ACL and the 4th International Joint Conference
on Natural Language Processing of the AFNLP,
pages 985–993, Suntec.
Gorman, Kyle. 2016. Pynini: A Python library
for weighted finite-state grammar
compilation. In Proceedings of the ACL
Workshop on Statistical NLP and Weighted
Automata, pages 75–80, Berlin.
Henderson, J. 2004. Discriminative training of
a neural network statistical parser. In 42nd
Annual Meeting of the Association for
Computational Linguistics, Proceedings of the
Conference, pages 95–102, Barcelona.
Hockenmaier, J. and M. Steedman. 2007.
CCGbank: A corpus of CCG derivations
and dependency structures extracted from
the Penn Treebank. Computational
Linguistics, 33(3):355–396.
Johnson, M. 2002. A simple pattern-matching
algorithm for recovering empty nodes and
their antecedents. In 40th Annual Meeting of
the Association for Computational Linguistics,
Proceedings of the Conference, pages 136–143,
Philadelphia, PA.
Kahane, S., A. Nasr, and O. Rambow. 1998.
Pseudo-projectivity, a polynomially
parsable non-projective dependency
grammar. In 36th Annual Meeting of the
Association for Computational Linguistics and
17th International Conference on
Computational Linguistics, volume 1,
pages 646–652, Montreal.
Kallmeyer, K. and M. Kuhlmann. 2012. A
formal model for plausible dependencies in
lexicalized tree adjoining grammar. In
Eleventh International Workshop on Tree
Adjoining Grammar and Related Formalisms,
pages 108–116, Paris.
Kallmeyer, L. and W. Maier. 2010. Data-driven
parsing with probabilistic linear
context-free rewriting systems. In the 23rd
International Conference on Computational
Linguistics, pages 537–545, Beijing.

517

Computational Linguistics

Kallmeyer, L. and W. Maier. 2013. Data-driven
parsing using probabilistic linear
context-free rewriting systems.
Computational Linguistics, 39(1):87–119.
Kallmeyer, Laura. 2010. Parsing Beyond
Context-Free Grammars. Springer-Verlag.
Kanazawa, M. 2009. The pumping lemma
for well-nested multiple context-free
languages. In Developments in Language
Theory, volume 5583 of Lecture Notes in
Computer Science, pages 312–325,
Springer-Verlag, Stuttgart.
Kanazawa, M. and S. Salvati. 2010. The
copying power of well-nested multiple
context-free grammars. In Language and
Automata Theory and Applications, volume
6031 of Lecture Notes in Computer Science,
pages 344–355, Trier.
Kathol, A. and C. Pollard. 1995. Extraposition
via complex domain formation. In 33rd
Annual Meeting of the Association for
Computational Linguistics, Proceedings
of the Conference, pages 174–180,
Cambridge, MA.
Kepser, S. and J. Rogers. 2011. The
equivalence of tree adjoining grammars
and monadic linear context-free tree
grammars. Journal of Logic, Language and
Information, 20:361–384.
Klein, D. and C. Manning. 2004.
Corpus-based induction of syntactic
structure: Models of dependency and
constituency. In 42nd Annual Meeting of the
Association for Computational Linguistics,
Proceedings of the Conference, pages 478–485,
Barcelona.
Klein, D. and C. D. Manning. 2003. A∗ parsing:
Fast exact Viterbi parse selection. In
Proceedings of the 2003 Human Language
Technology Conference of the North American
Chapter of the Association for Computational
Linguistics, pages 40–47, Edmonton.
Knuth, D. E. 1968. Semantics of context-free
languages. Mathematical Systems Theory,
2:127–145. Corrections in Mathematical
Systems Theory, 5 (1971):95–96.
Kübler, S., R. McDonald, and J. Nivre.
2009. Dependency Parsing, volume 2(1) of
Synthesis Lectures on Human Language
Technologies. Morgan & Claypool Publishers
LLC.
Kuhlmann, M. 2013. Mildly non-projective
dependency grammar. Computational
Linguistics, 39(2):355–387.
Kuhlmann, M. and G. Satta. 2009. Treebank
grammar techniques for non-projective
dependency parsing. In Proceedings of the
12th Conference of the European Chapter of the
Association for Computational Linguistics,
pages 478–486, Athens.

518

Volume 43, Number 3

Kuhlmann, Marco and Joachim Niehren. 2008.
Logics and automata for totally ordered
trees. In Rewriting Techniques and
Applications: 19th International Conference,
pages 217–231, Hagenberg.
Lu, W., H. T. Ng, W. S. Lee, and L. S.
Zettlemoyer. 2008. A generative model for
parsing natural language to meaning
representations. In Proceedings of the
2008 Conference on Empirical Methods
in Natural Language Processing,
pages 783–792, Honolulu, HI.
Maier, W. and L. Kallmeyer. 2010.
Discontinuity and non-projectivity: Using
mildly context-sensitive formalisms for
data-driven parsing. In Tenth International
Workshop on Tree Adjoining Grammar and
Related Formalisms, pages 119–126, New
Haven, CT.
Maier, W. and A. Søgaard. 2008. Treebanks
and mild context-sensitivity. In Proceedings
of the 13th Conference on Formal Grammar,
pages 61–76, Hamburg.
Maier, Wolfgang and Timm Lichte. 2009.
Characterizing discontinuity in constituent
treebanks. In Proceedings of the 14th
Conference on Formal Grammar, volume 5591
of Lecture Notes in Artificial Intelligence,
pages 167–182, Bordeaux.
Maletti, A. and J. Engelfriet. 2012. Strong
lexicalization of tree adjoining grammars.
In 50th Annual Meeting of the Association for
Computational Linguistics, Proceedings of the
Conference, pages 506–515, Jeju Island.
Marcus, M. P., B. Santorini, and M. A.
Marcinkiewicz. 1993. Building a large
annotated corpus of English: The Penn
Treebank. Computational Linguistics,
19(2):313–330.
McCawley, J. D. 1982. Parentheticals and
discontinuous constituent structure.
Linguistic Inquiry, 13(1):91–106.
McDonald, R. and F. Pereira. 2006. Online
learning of approximate dependency
parsing algorithms. In Proceedings of the 11th
Conference of the European Chapter of the
Association for Computational Linguistics,
pages 81–88, Trento.
McDonald, R., F. Pereira, K. Ribarov, and
J. Hajič. 2005. Non-projective dependency
parsing using spanning tree algorithms. In
Human Language Technology Conference and
Conference on Empirical Methods in Natural
Language Processing, pages 523–530,
Vancouver.
Mel’čuk, I. A. 1988. Dependency Syntax: Theory
and Practice. State University of New York
Press, Albany.
Mönnich, U. 2010. Well-nested tree languages
and attributed tree transducers. In Tenth

Gebhardt, Nederhof, and Vogler

International Workshop on Tree Adjoining
Grammar and Related Formalisms,
pages 35–44, New Haven, CT.
Müller, S. 2004. Continuous or discontinuous
constituents? A comparison between
syntactic analyses for constituent order and
their processing systems. Research on
Language and Computation, 2:209–257.
Nederhof, M.-J. and H. Vogler. 2014. Hybrid
grammars for discontinuous parsing.
In the 25th International Conference on
Computational Linguistics: Technical Papers,
pages 1370–1381, Dublin.
Nivre, J. 2010. Statistical parsing. In
N. Indurkhya and F. J. Damerau, editors,
Handbook of Natural Language Processing.
Second Edition. CRC Press, Taylor and
Francis Group, pages 237–266.
Nivre, J. and J. Nilsson. 2005.
Pseudo-projective dependency parsing. In
43rd Annual Meeting of the Association for
Computational Linguistics, Proceedings of the
Conference, pages 99–106, Ann Arbor, MI.
Nivre, Joakim. 2009. Non-projective
dependency parsing in expected linear
time. In Proceedings of the Joint Conference of
the 47th Annual Meeting of the ACL and the
4th International Joint Conference on Natural
Language Processing of the AFNLP, pages
351–359, Suntec.
Nivre, Joakim, Johan Hall, and Jens Nilsson.
2006. Maltparser: A data-driven
parser-generator for dependency parsing.
In LREC 2006: Fifth International Conference
on Language Resources and Evaluation,
Proceedings, pages 2216–2219, Genoa.
Nivre, Joakim, Marco Kuhlmann, and Johan
Hall. 2009. An improved oracle for
dependency parsing with online reordering.
In Proceedings of the 11th International
Conference on Parsing Technologies, pages
73–76, Paris.
Paakki, J. 1995. Attribute grammar paradigms
— a high level methodology in language
implementation. ACM Computing Surveys,
27(2):196–255.
Petrov, S., L. Barrett, R. Thibaux, and D. Klein.
2006. Learning accurate, compact, and
interpretable tree annotation. In Proceedings
of the 21st International Conference on
Computational Linguistics and 44th Annual
Meeting of the Association for Computational
Linguistics, pages 433–440, Sydney.
Pollard C. and I. A. Sag. 1994. Head-Driven
Phrase Structure Grammar. University of
Chicago Press.
Rambow, O. 2010. The simple truth about
dependency and phrase structure
representations: An opinion piece. In
Human Language Technologies: The 2010

Hybrid Grammars

Annual Conference of the North American
Chapter of the Association for Computational
Linguistics, Proceedings of the Main
Conference, pages 337–340, Los Angeles, CA.
Rambow, O. and A. K. Joshi. 1997. A formal
look at dependency grammars and phrase
structure grammars with special
consideration of word-order phenomena. In
L. Wenner, editor, Recent Trends in
Meaning-Text Theory. John Benjamin, pages
167–190.
Ranta, Aarne. 2011. Grammatical Framework:
Programming with Multilingual Grammars,
CSLI Publications, Stanford, CA.
Reape, M. 1989. A logical treatment of
semi-free word order and bounded
discontinuous constituency. In Fourth
Conference of the European Chapter of the
Association for Computational Linguistics,
Proceedings of the Conference, pages 103–110,
Manchester.
Reape, M. 1994. Domain union and word
order variation in German. In J. Nerbonne,
K. Netter, and C. Pollard, editors, German in
Head-Driven Phrase Structure Grammar. CSLI
Publications, Stamford, CA, pages 151–197.
Rounds, W. C. 1970. Mappings and grammars
on trees. Mathematical Systems Theory,
4:257–287.
Satta, G. and M. Kuhlmann. 2013. Efficient
parsing for head-split dependency trees.
Transactions of the Association for
Computational Linguistics, 1:267–278.
Satta, G. and E. Peserico. 2005. Some
computational complexity results for
synchronous context-free grammars. In
Human Language Technology Conference and
Conference on Empirical Methods in Natural
Language Processing, pages 803–810,
Vancouver.
Seifert, S. and I. Fischer. 2004. Parsing string
generating hypergraph grammars. In
Proceedings of the 2nd International Conference
on Graph Transformations, volume 3256 of
Lecture Notes in Computer Science, pages
352–267, Springer-Verlag, Rome.
Seki, H. and Y. Kato. 2008. On the generative
power of multiple context-free grammars
and macro grammars. IEICE Transactions on
Information and Systems, E91-D:209–221.
Seki, H., T. Matsumura, M. Fujii, and
T. Kasami. 1991. On multiple context-free
grammars. Theoretical Computer Science,
88:191–229.
Shieber, S. M. 1985. Evidence against the
context-freeness of natural language.
Linguistics and Philosophy, 8(3):333–343.
Shieber, S. M. and Y. Schabes. 1990.
Synchronous tree-adjoining grammars. In
Papers Presented to the 13th International

519

Computational Linguistics

Conference on Computational Linguistics,
volume 3, pages 253–258, Helsinki.
Sima’an, K., R. Bod, S. Krauwer, and
R. Scha. 1994. Efficient disambiguation
by means of stochastic tree substitution
grammars. In Proceedings of International
Conference on New Methods in Language
Processing, pages 50–58, Manchester.
Skut, W., B. Krenn, T. Brants, and H.
Uszkoreit. 1997. An annotation scheme
for free word order languages.
In Fifth Conference on Applied Natural
Language Processing, pages 88–95,
Washington, DC.
Stucky, S. 1987. Configurational variation in
English. In G. J. Huck and A. E. Ojeda,

520

Volume 43, Number 3

editors, Discontinuous Constituency,
volume 20 of Syntax and Semantics.
Academic Press, pages 377–404.
Vijay-Shankar, K. and A. K. Joshi. 1985. Some
computational properties of tree adjoining
grammars. In 23rd Annual Meeting of the
Association for Computational Linguistics,
Proceedings of the Conference, pages 82–93,
Chicago, IL.
Vijay-Shanker, K., D. J. Weir, and A. K. Joshi.
1987. Characterizing structural descriptions
produced by various grammatical
formalisms. In 25th Annual Meeting of the
Association for Computational Linguistics,
Proceedings of the Conference, pages 104–111,
Stanford, CA.

